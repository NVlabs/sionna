<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multiple-Input Multiple-Output (MIMO) &mdash; Sionna 0.17.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/sionna.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5G NR" href="nr.html" />
    <link rel="prev" title="Orthogonal Frequency-Division Multiplexing (OFDM)" href="ofdm.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Sionna
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../installation.html#installation-using-pip">Installation using pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../installation.html#docker-based-installation">Docker-based Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../installation.html#installation-from-source">Installation from source</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Hello_World.html">“Hello, world!”</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/Discover_Sionna.html">Discover Sionna</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Load-Required-Packages">Load Required Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Sionna-Data-flow-and-Design-Paradigms">Sionna Data-flow and Design Paradigms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Let’s-Get-Started---The-First-Layers-(Eager-Mode)">Let’s Get Started - The First Layers (<em>Eager Mode</em>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Batches-and-Multi-dimensional-Tensors">Batches and Multi-dimensional Tensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#First-Link-level-Simulation">First Link-level Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Setting-up-the-End-to-end-Model">Setting up the End-to-end Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Run-some-Throughput-Tests-(Graph-Mode)">Run some Throughput Tests (Graph Mode)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Bit-Error-Rate-(BER)-Monte-Carlo-Simulations">Bit-Error Rate (BER) Monte-Carlo Simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/Discover_Sionna.html#Conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials.html#for-beginners">For Beginners</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html">Part 1: Getting Started with Sionna</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Imports-&amp;-Basics">Imports &amp; Basics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Sionna-Data-flow-and-Design-Paradigms">Sionna Data-flow and Design Paradigms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Hello,-Sionna!">Hello, Sionna!</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Communication-Systems-as-Keras-Models">Communication Systems as Keras Models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Forward-Error-Correction-(FEC)">Forward Error Correction (FEC)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Eager-vs-Graph-Mode">Eager vs Graph Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part1.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_tutorial_part2.html">Part 2: Differentiable Communication Systems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part2.html#Imports">Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part2.html#Gradient-Computation-Through-End-to-end-Systems">Gradient Computation Through End-to-end Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part2.html#Creating-Custom-Layers">Creating Custom Layers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part2.html#Setting-up-Training-Loops">Setting up Training Loops</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html">Part 3: Advanced Link-level Simulations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#Imports">Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#OFDM-Resource-Grid-and-Stream-Management">OFDM Resource Grid and Stream Management</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#Stream-Management">Stream Management</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#OFDM-Resource-Grid">OFDM Resource Grid</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#Antenna-Arrays">Antenna Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#Channel-Model">Channel Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part3.html#Uplink-Transmission-in-the-Frequency-Domain">Uplink Transmission in the Frequency Domain</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html">Part 4: Toward Learned Receivers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#Imports">Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#Simulation-Parameters">Simulation Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#Implemention-of-an-Advanced-Neural-Receiver">Implemention of an Advanced Neural Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#Training-the-Neural-Receiver">Training the Neural Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#Benchmarking-the-Neural-Receiver">Benchmarking the Neural Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#Conclusion">Conclusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_tutorial_part4.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html">Basic MIMO Simulations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html#Table-of-Contents">Table of Contents</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html#Simple-uncoded-transmission">Simple uncoded transmission</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html#Adding-spatial-correlation">Adding spatial correlation</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html#Extension-to-channel-coding">Extension to channel coding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Simple_MIMO_Simulation.html#BER-simulations-using-a-Keras-model">BER simulations using a Keras model</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Pulse_shaping_basics.html">Pulse-shaping Basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Pulse_shaping_basics.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Pulse_shaping_basics.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Pulse_shaping_basics.html#Pulse-shaping-of-a-sequence-of-QAM-symbols">Pulse-shaping of a sequence of QAM symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Pulse_shaping_basics.html#Recovering-the-QAM-symbols-through-matched-filtering-and-downsampling">Recovering the QAM symbols through matched filtering and downsampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Pulse_shaping_basics.html#Investigating-the-ACLR">Investigating the ACLR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Pulse_shaping_basics.html#Windowing">Windowing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html">Optical Channel with Lumped Amplification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Impulse-Generation">Impulse Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Attenuation">Attenuation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Amplified-Spontaneous-Emission-Noise">Amplified Spontaneous Emission Noise</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Channel-Configuration">Channel Configuration</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Transmission">Transmission</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Chromatic-Dispersion">Chromatic Dispersion</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#id1">Channel Configuration</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#id2">Transmission</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Kerr-Nonlinearity">Kerr Nonlinearity</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Channel-configuration">Channel configuration</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#id4">Transmission</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#Split-Step-Fourier-Method">Split-Step Fourier Method</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#id5">Channel Configuration</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#id6">Transmission</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Optical_Lumped_Amplification_Channel.html#References">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials.html#for-experts">For Experts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html">5G Channel Coding and Rate-Matching: Polar vs. LDPC Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#BER-Performance-of-5G-Coding-Schemes">BER Performance of 5G Coding Schemes</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#Performance-under-Optimal-Decoding">Performance under Optimal Decoding</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#Performance-of-Longer-LDPC-Codes">Performance of Longer LDPC Codes</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#A-Deeper-Look-into-the-Polar-Code-Module">A Deeper Look into the Polar Code Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#Rate-Matching-and-Rate-Recovery">Rate-Matching and Rate-Recovery</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#Throughput-and-Decoding-Complexity">Throughput and Decoding Complexity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_Channel_Coding_Polar_vs_LDPC_Codes.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/5G_NR_PUSCH.html">5G NR PUSCH Tutorial</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#A-Hello-World-Example">A Hello World Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Carrier-Configuration">Carrier Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Understanding-the-DMRS-Configuration">Understanding the DMRS Configuration</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Configuring-Multiple-Layers">Configuring Multiple Layers</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Controlling-the-Number-of-DMRS-Symbols-in-a-Slot">Controlling the Number of DMRS Symbols in a Slot</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#How-to-control-the-number-of-available-DMRS-ports?">How to control the number of available DMRS ports?</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Transport-Blocks-and-MCS">Transport Blocks and MCS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Looking-into-the-PUSCHTransmitter">Looking into the PUSCHTransmitter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#Components-of-the-PUSCHReceiver">Components of the PUSCHReceiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/5G_NR_PUSCH.html#End-to-end-PUSCH-Simulations">End-to-end PUSCH Simulations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html">Bit-Interleaved Coded Modulation (BICM)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#System-Block-Diagram">System Block Diagram</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#A-Simple-BICM-System">A Simple BICM System</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#Constellations-and-Bit-Channels">Constellations and Bit-Channels</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#Simple-BER-Simulations">Simple BER Simulations</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#All-zero-Codeword-Simulations">All-zero Codeword Simulations</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#Remove-Encoder:-Simulate-QPSK-with-All-zero-Codeword-Transmission">Remove Encoder: Simulate QPSK with All-zero Codeword Transmission</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#Remove-(De-)Mapping:-Approximate-the-LLR-Distribution-of-the-All-zero-Codeword-(and-BPSK/QPSK)">Remove (De-)Mapping: Approximate the LLR Distribution of the All-zero Codeword (and BPSK/QPSK)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#The-Role-of-the-Scrambler">The Role of the Scrambler</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#EXIT-Charts">EXIT Charts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#Mismatched-Demapping-and-the-Advantages-of-Min-sum-Decoding">Mismatched Demapping and the Advantages of Min-sum Decoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Bit_Interleaved_Coded_Modulation.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html">MIMO OFDM Transmissions over the CDL Channel Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Table-of-Contents">Table of Contents</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#System-Setup">System Setup</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Stream-Management">Stream Management</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#OFDM-Resource-Grid-&amp;-Pilot-Pattern">OFDM Resource Grid &amp; Pilot Pattern</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Antenna-Arrays">Antenna Arrays</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#CDL-Channel-Model">CDL Channel Model</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Other-Physical-Layer-Components">Other Physical Layer Components</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Simulations">Simulations</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Uplink-Transmission-in-the-Frequency-Domain">Uplink Transmission in the Frequency Domain</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Uplink-Transmission-in-the-Time-Domain">Uplink Transmission in the Time Domain</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Downlink-Transmission-in-the-Frequency-Domain">Downlink Transmission in the Frequency Domain</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Understand-the-Difference-Between-the-CDL-Models">Understand the Difference Between the CDL Models</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Create-an-End-to-End-Keras-Model">Create an End-to-End Keras Model</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Compare-Uplink-Performance-Over-the-Different-CDL-Models">Compare Uplink Performance Over the Different CDL Models</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Compare-Downlink-Performance-Over-the-Different-CDL-Models">Compare Downlink Performance Over the Different CDL Models</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Evaluate-the-Impact-of-Mobility">Evaluate the Impact of Mobility</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/MIMO_OFDM_Transmissions_over_CDL.html#Evaluate-the-Impact-of-Insufficient-Cyclic-Prefix-Length">Evaluate the Impact of Insufficient Cyclic Prefix Length</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Neural_Receiver.html">Neural Receiver for OFDM SIMO Systems</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#Simulation-Parameters">Simulation Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#Neural-Receiver">Neural Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#End-to-end-System">End-to-end System</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#End-to-end-System-as-a-Keras-Model">End-to-end System as a Keras Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#Evaluation-of-the-Baselines">Evaluation of the Baselines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#Training-the-Neural-Receiver">Training the Neural Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#Evaluation-of-the-Neural-Receiver">Evaluation of the Neural Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#Pre-computed-Results">Pre-computed Results</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Neural_Receiver.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html">Realistic Multiuser MIMO OFDM Simulations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#System-Setup">System Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#Uplink-Transmissions-in-the-Frequency-Domain">Uplink Transmissions in the Frequency Domain</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#Compare-Estimated-and-Actual-Frequency-Responses">Compare Estimated and Actual Frequency Responses</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#Understand-the-Difference-Between-the-Channel-Models">Understand the Difference Between the Channel Models</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Realistic_Multiuser_MIMO_Simulations.html#Setup-a-Keras-Model-for-BER-simulations">Setup a Keras Model for BER simulations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html">OFDM MIMO Channel Estimation and Detection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#Simulation-parameters">Simulation parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#Estimation-of-the-channel-time,-frequency,-and-spatial-covariance-matrices">Estimation of the channel time, frequency, and spatial covariance matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#Loading-the-channel-covariance-matrices">Loading the channel covariance matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#Comparison-of-OFDM-estimators">Comparison of OFDM estimators</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#End-to-end-model">End-to-end model</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#Comparison-of-MIMO-detectors">Comparison of MIMO detectors</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/OFDM_MIMO_Detection.html#id1">End-to-end model</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html">Introduction to Iterative Detection and Decoding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Iterative-Detection-and-Decoding">Iterative Detection and Decoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Table-of-contents">Table of contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Simulation-Parameters">Simulation Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Setting-up-the-Keras-Models">Setting-up the Keras Models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Non-IDD-versus-IDD-Benchmarks">Non-IDD versus IDD Benchmarks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Discussion-Optimizing-IDD-with-Machine-Learning">Discussion-Optimizing IDD with Machine Learning</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#Comments">Comments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Introduction_to_Iterative_Detection_and_Decoding.html#List-of-References">List of References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Autoencoder.html">End-to-end Learning with Autoencoders</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#Simulation-Parameters">Simulation Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#Neural-Demapper">Neural Demapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#Trainable-End-to-end-System:-Conventional-Training">Trainable End-to-end System: Conventional Training</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#Trainable-End-to-end-System:-RL-based-Training">Trainable End-to-end System: RL-based Training</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#Evaluation">Evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#Visualizing-the-Learned-Constellations">Visualizing the Learned Constellations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Autoencoder.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html">Weighted Belief Propagation Decoding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Weighted-BP-for-BCH-Codes">Weighted BP for BCH Codes</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Weights-before-Training-and-Simulation-of-BER">Weights <em>before</em> Training and Simulation of BER</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Training">Training</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Results">Results</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Further-Experiments">Further Experiments</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Damped-BP">Damped BP</a></li>
<li class="toctree-l5"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#Learning-the-5G-LDPC-Code">Learning the 5G LDPC Code</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Weighted_BP_Algorithm.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/CIR_Dataset.html">Channel Models from Datasets</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/CIR_Dataset.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/CIR_Dataset.html#Simulation-Parameters">Simulation Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/CIR_Dataset.html#Creating-a-Simple-Dataset">Creating a Simple Dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/CIR_Dataset.html#Generators">Generators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/CIR_Dataset.html#Use-the-Channel-Model-for-OFDM-Transmissions">Use the Channel Model for OFDM Transmissions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DeepMIMO.html">Using the DeepMIMO Dataset with Sionna</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/DeepMIMO.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/DeepMIMO.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/DeepMIMO.html#Configuration-of-DeepMIMO">Configuration of DeepMIMO</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/DeepMIMO.html#Visualization-of-the-dataset">Visualization of the dataset</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/DeepMIMO.html#Using-DeepMIMO-with-Sionna">Using DeepMIMO with Sionna</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/DeepMIMO.html#Random-Sampling-of-Multi-User-Channels">Random Sampling of Multi-User Channels</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/DeepMIMO.html#Link-level-Simulations-using-Sionna-and-DeepMIMO">Link-level Simulations using Sionna and DeepMIMO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/DeepMIMO.html#DeepMIMO-License-and-Citation">DeepMIMO License and Citation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials.html#ray-tracing">Ray Tracing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html">Introduction to Sionna RT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Background-Information">Background Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Loading-Scenes">Loading Scenes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Ray-Tracing-for-Radio-Propagation">Ray Tracing for Radio Propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#From-Paths-to-Channel-Impulse-Responses">From Paths to Channel Impulse Responses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#BER-Evaluation">BER Evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Runtime-vs-Depth">Runtime vs Depth</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Coverage-Map">Coverage Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Site-specifc-Link-Level-Simulations">Site-specifc Link-Level Simulations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Introduction.html#Conclusion-and-Outlook">Conclusion and Outlook</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html">Tutorial on Diffraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#Background-Information">Background Information</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#Wedge-vs-Edge">Wedge vs Edge</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#Experiments-with-a-Simple-Wedge">Experiments with a Simple Wedge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#Coverage-Maps-with-Diffraction">Coverage Maps with Diffraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Diffraction.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html">Tutorial on Scattering</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Scattering-Basics">Scattering Basics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Scattering-Patterns">Scattering Patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Validation-Against-the-“Far”-Wall-Approximation">Validation Against the “Far”-Wall Approximation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Coverage-Maps-With-Scattering">Coverage Maps With Scattering</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Impact-on-Channel-Impulse-Response">Impact on Channel Impulse Response</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#Summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Scattering.html#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html">Mobility in Sionna RT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Table-of-Contents">Table of Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Background-Information">Background Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#GPU-Configuration-and-Imports">GPU Configuration and Imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Controlling-Position-and-Orientation-of-Scene-Objects">Controlling Position and Orientation of Scene Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Time-Evolution-of-Channels-Via-Doppler-Shift">Time Evolution of Channels Via Doppler Shift</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Example:-Delay-Doppler-Spectrum">Example: Delay-Doppler Spectrum</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Comparison-of-Doppler--vs-Position-based-Time-Evolution">Comparison of Doppler- vs Position-based Time Evolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../examples/Sionna_Ray_Tracing_Mobility.html#Summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../made_with_sionna.html">“Made with Sionna”</a></li>
<li class="toctree-l1"><a class="reference internal" href="../em_primer.html">Primer on Electromagnetics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#coordinate-system-rotations-and-vector-fields">Coordinate system, rotations, and vector fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#planar-time-harmonic-waves">Planar Time-Harmonic Waves</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#far-field-of-a-transmitting-antenna">Far Field of a Transmitting Antenna</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#modelling-of-a-receiving-antenna">Modelling of a Receiving Antenna</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#general-propagation-path">General Propagation Path</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#frequency-impulse-response">Frequency &amp; Impulse Response</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#reflection-and-refraction">Reflection and Refraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#diffraction">Diffraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../em_primer.html#scattering">Scattering</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="sionna.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="fec.html">Forward Error Correction (FEC)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="fec.linear.html">Linear Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.linear.html#encoder">Encoder</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.linear.html#linearencoder">LinearEncoder</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.linear.html#allzeroencoder">AllZeroEncoder</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.linear.html#decoder">Decoder</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.linear.html#osdecoder">OSDecoder</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.ldpc.html">Low-Density Parity-Check (LDPC)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.ldpc.html#ldpc-encoder">LDPC Encoder</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.ldpc.html#ldpc5gencoder">LDPC5GEncoder</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.ldpc.html#ldpc-decoder">LDPC Decoder</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.ldpc.html#ldpcbpdecoder">LDPCBPDecoder</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.ldpc.html#ldpc5gdecoder">LDPC5GDecoder</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.polar.html">Polar Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.polar.html#polar-encoding">Polar Encoding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#polar5gencoder">Polar5GEncoder</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#polarencoder">PolarEncoder</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.polar.html#polar-decoding">Polar Decoding</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#polar5gdecoder">Polar5GDecoder</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#polarscdecoder">PolarSCDecoder</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#polarscldecoder">PolarSCLDecoder</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#polarbpdecoder">PolarBPDecoder</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.polar.html#polar-utility-functions">Polar Utility Functions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#generate-5g-ranking">generate_5g_ranking</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#generate-polar-transform-mat">generate_polar_transform_mat</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#generate-rm-code">generate_rm_code</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.polar.html#generate-dense-polar">generate_dense_polar</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.conv.html">Convolutional Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.conv.html#convolutional-encoding">Convolutional Encoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.conv.html#viterbi-decoding">Viterbi Decoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.conv.html#bcjr-decoding">BCJR Decoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.conv.html#convolutional-code-utility-functions">Convolutional Code Utility Functions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.conv.html#trellis">Trellis</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.conv.html#polynomial-selector">polynomial_selector</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.turbo.html">Turbo Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.turbo.html#turbo-encoding">Turbo Encoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.turbo.html#turbo-decoding">Turbo Decoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.turbo.html#turbo-utility-functions">Turbo Utility Functions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.turbo.html#turbotermination">TurboTermination</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.turbo.html#polynomial-selector">polynomial_selector</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.turbo.html#puncture-pattern">puncture_pattern</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.crc.html">Cyclic Redundancy Check (CRC)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.crc.html#crcencoder">CRCEncoder</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.crc.html#crcdecoder">CRCDecoder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.interleaving.html">Interleaving</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.interleaving.html#interleaver">Interleaver</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.interleaving.html#rowcolumninterleaver">RowColumnInterleaver</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.interleaving.html#randominterleaver">RandomInterleaver</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.interleaving.html#turbo3gppinterleaver">Turbo3GPPInterleaver</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.interleaving.html#deinterleaver">Deinterleaver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.scrambling.html">Scrambling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.scrambling.html#scrambler">Scrambler</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.scrambling.html#tb5gscrambler">TB5GScrambler</a></li>
<li class="toctree-l4"><a class="reference internal" href="fec.scrambling.html#descrambler">Descrambler</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fec.utils.html">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="fec.utils.html#binary-linear-codes">(Binary) Linear Codes</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#load-parity-check-examples">load_parity_check_examples</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#alist2mat">alist2mat</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#load-alist">load_alist</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#generate-reg-ldpc">generate_reg_ldpc</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#make-systematic">make_systematic</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#gm2pcm">gm2pcm</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#pcm2gm">pcm2gm</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#verify-gm-pcm">verify_gm_pcm</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.utils.html#exit-analysis">EXIT Analysis</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#plot-exit-chart">plot_exit_chart</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#get-exit-analytic">get_exit_analytic</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#plot-trajectory">plot_trajectory</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="fec.utils.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#gaussianpriorsource">GaussianPriorSource</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#bin2int">bin2int</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#int2bin">int2bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#bin2int-tf">bin2int_tf</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#int2bin-tf">int2bin_tf</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#int-mod-2">int_mod_2</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#llr2mi">llr2mi</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#j-fun">j_fun</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#j-fun-inv">j_fun_inv</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#j-fun-tf">j_fun_tf</a></li>
<li class="toctree-l5"><a class="reference internal" href="fec.utils.html#j-fun-inv-tf">j_fun_inv_tf</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mapping.html">Mapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mapping.html#constellations">Constellations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#constellation">Constellation</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#qam">qam</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#pam">pam</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#pam-gray">pam_gray</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mapping.html#mapper">Mapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="mapping.html#demapping">Demapping</a><ul>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#demapper">Demapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#demapperwithprior">DemapperWithPrior</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#symboldemapper">SymbolDemapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#symboldemapperwithprior">SymbolDemapperWithPrior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mapping.html#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#symbollogits2llrs">SymbolLogits2LLRs</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#llrs2symbollogits">LLRs2SymbolLogits</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#symbollogits2llrswithprior">SymbolLogits2LLRsWithPrior</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#symbollogits2moments">SymbolLogits2Moments</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#symbolinds2bits">SymbolInds2Bits</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#pam2qam">PAM2QAM</a></li>
<li class="toctree-l4"><a class="reference internal" href="mapping.html#qam2pam">QAM2PAM</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="channel.html">Channel</a><ul>
<li class="toctree-l3"><a class="reference internal" href="channel.wireless.html">Wireless</a><ul>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#awgn">AWGN</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#flat-fading-channel">Flat-fading channel</a><ul>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#flatfadingchannel">FlatFadingChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#generateflatfadingchannel">GenerateFlatFadingChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#applyflatfadingchannel">ApplyFlatFadingChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#spatialcorrelation">SpatialCorrelation</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#kroneckermodel">KroneckerModel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#percolumnmodel">PerColumnModel</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#channel-model-interface">Channel model interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#time-domain-channel">Time domain channel</a><ul>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#timechannel">TimeChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#generatetimechannel">GenerateTimeChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#applytimechannel">ApplyTimeChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#cir-to-time-channel">cir_to_time_channel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#time-to-ofdm-channel">time_to_ofdm_channel</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#channel-with-ofdm-waveform">Channel with OFDM waveform</a><ul>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#ofdmchannel">OFDMChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#generateofdmchannel">GenerateOFDMChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#applyofdmchannel">ApplyOFDMChannel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#cir-to-ofdm-channel">cir_to_ofdm_channel</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#rayleigh-block-fading">Rayleigh block fading</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#gpp-38-901-channel-models">3GPP 38.901 channel models</a><ul>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#panelarray">PanelArray</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#antenna">Antenna</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#antennaarray">AntennaArray</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#tapped-delay-line-tdl">Tapped delay line (TDL)</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#clustered-delay-line-cdl">Clustered delay line (CDL)</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#urban-microcell-umi">Urban microcell (UMi)</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#urban-macrocell-uma">Urban macrocell (UMa)</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#rural-macrocell-rma">Rural macrocell (RMa)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#external-datasets">External datasets</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.wireless.html#utility-functions">Utility functions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#subcarrier-frequencies">subcarrier_frequencies</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#time-lag-discrete-time-channel">time_lag_discrete_time_channel</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#deg-2-rad">deg_2_rad</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#rad-2-deg">rad_2_deg</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#wrap-angle-0-360">wrap_angle_0_360</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#drop-uts-in-sector">drop_uts_in_sector</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#relocate-uts">relocate_uts</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#set-3gpp-scenario-parameters">set_3gpp_scenario_parameters</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#gen-single-sector-topology">gen_single_sector_topology</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#gen-single-sector-topology-interferers">gen_single_sector_topology_interferers</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#exp-corr-mat">exp_corr_mat</a></li>
<li class="toctree-l5"><a class="reference internal" href="channel.wireless.html#one-ring-corr-mat">one_ring_corr_mat</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="channel.optical.html">Optical</a><ul>
<li class="toctree-l4"><a class="reference internal" href="channel.optical.html#split-step-fourier-method">Split-step Fourier method</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.optical.html#erbium-doped-fiber-amplifier">Erbium-doped fiber amplifier</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.optical.html#utility-functions">Utility functions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="channel.optical.html#time-frequency-vector">time_frequency_vector</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="channel.discrete.html">Discrete</a><ul>
<li class="toctree-l4"><a class="reference internal" href="channel.discrete.html#binarymemorylesschannel">BinaryMemorylessChannel</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.discrete.html#binarysymmetricchannel">BinarySymmetricChannel</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.discrete.html#binaryerasurechannel">BinaryErasureChannel</a></li>
<li class="toctree-l4"><a class="reference internal" href="channel.discrete.html#binaryzchannel">BinaryZChannel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ofdm.html">Orthogonal Frequency-Division Multiplexing (OFDM)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#resource-grid">Resource Grid</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#resourcegrid">ResourceGrid</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#resourcegridmapper">ResourceGridMapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#resourcegriddemapper">ResourceGridDemapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#removenulledsubcarriers">RemoveNulledSubcarriers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#modulation-demodulation">Modulation &amp; Demodulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#ofdmmodulator">OFDMModulator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#ofdmdemodulator">OFDMDemodulator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#pilot-pattern">Pilot Pattern</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#pilotpattern">PilotPattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#emptypilotpattern">EmptyPilotPattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#kroneckerpilotpattern">KroneckerPilotPattern</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#channel-estimation">Channel Estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#basechannelestimator">BaseChannelEstimator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#basechannelinterpolator">BaseChannelInterpolator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#lschannelestimator">LSChannelEstimator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#linearinterpolator">LinearInterpolator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#lmmseinterpolator">LMMSEInterpolator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#nearestneighborinterpolator">NearestNeighborInterpolator</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#tdl-time-cov-mat">tdl_time_cov_mat</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#tdl-freq-cov-mat">tdl_freq_cov_mat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#precoding">Precoding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#zfprecoder">ZFPrecoder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#equalization">Equalization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#ofdmequalizer">OFDMEqualizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#lmmseequalizer">LMMSEEqualizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#mfequalizer">MFEqualizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#zfequalizer">ZFEqualizer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ofdm.html#detection">Detection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#ofdmdetector">OFDMDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#ofdmdetectorwithprior">OFDMDetectorWithPrior</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#epdetector">EPDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#kbestdetector">KBestDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#lineardetector">LinearDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#maximumlikelihooddetector">MaximumLikelihoodDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#maximumlikelihooddetectorwithprior">MaximumLikelihoodDetectorWithPrior</a></li>
<li class="toctree-l4"><a class="reference internal" href="ofdm.html#mmsepicdetector">MMSEPICDetector</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Multiple-Input Multiple-Output (MIMO)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stream-management">Stream Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#precoding">Precoding</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#zero-forcing-precoder">zero_forcing_precoder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#equalization">Equalization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lmmse-equalizer">lmmse_equalizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mf-equalizer">mf_equalizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zf-equalizer">zf_equalizer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#detection">Detection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#epdetector">EPDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kbestdetector">KBestDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lineardetector">LinearDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maximumlikelihooddetector">MaximumLikelihoodDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maximumlikelihooddetectorwithprior">MaximumLikelihoodDetectorWithPrior</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mmse-pic">MMSE-PIC</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#list2llr">List2LLR</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list2llrsimple">List2LLRSimple</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complex2real-vector">complex2real_vector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real2complex-vector">real2complex_vector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complex2real-matrix">complex2real_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real2complex-matrix">real2complex_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complex2real-covariance">complex2real_covariance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real2complex-covariance">real2complex_covariance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complex2real-channel">complex2real_channel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real2complex-channel">real2complex_channel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#whiten-channel">whiten_channel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="nr.html">5G NR</a><ul>
<li class="toctree-l3"><a class="reference internal" href="nr.html#carrier">Carrier</a><ul>
<li class="toctree-l4"><a class="reference internal" href="nr.html#carrierconfig">CarrierConfig</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nr.html#layer-mapping">Layer Mapping</a><ul>
<li class="toctree-l4"><a class="reference internal" href="nr.html#layermapper">LayerMapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#layerdemapper">LayerDemapper</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nr.html#pusch">PUSCH</a><ul>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschconfig">PUSCHConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschdmrsconfig">PUSCHDMRSConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschlschannelestimator">PUSCHLSChannelEstimator</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschpilotpattern">PUSCHPilotPattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschprecoder">PUSCHPrecoder</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschreceiver">PUSCHReceiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#puschtransmitter">PUSCHTransmitter</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nr.html#transport-block">Transport Block</a><ul>
<li class="toctree-l4"><a class="reference internal" href="nr.html#tbconfig">TBConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#tbencoder">TBEncoder</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#tbdecoder">TBDecoder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nr.html#utils">Utils</a><ul>
<li class="toctree-l4"><a class="reference internal" href="nr.html#calculate-tb-size">calculate_tb_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#generate-prng-seq">generate_prng_seq</a></li>
<li class="toctree-l4"><a class="reference internal" href="nr.html#select-mcs">select_mcs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rt.html">Ray Tracing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="rt.html#scene">Scene</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#id1">Scene</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#compute-paths">compute_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#trace-paths">trace_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#compute-fields">compute_fields</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#coverage-map">coverage_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#load-scene">load_scene</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#preview">preview</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#render">render</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#render-to-file">render_to_file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#example-scenes">Example Scenes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#floor-wall">floor_wall</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#simple-street-canyon">simple_street_canyon</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#simple-street-canyon-with-cars">simple_street_canyon_with_cars</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#etoile">etoile</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#munich">munich</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#simple-wedge">simple_wedge</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#simple-reflector">simple_reflector</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#double-reflector">double_reflector</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#triple-reflector">triple_reflector</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#box">Box</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#paths">Paths</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#id13">Paths</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#coverage-maps">Coverage Maps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#coveragemap">CoverageMap</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#cameras">Cameras</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#camera">Camera</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#scene-objects">Scene Objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#sceneobject">SceneObject</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#radio-materials">Radio Materials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#radiomaterial">RadioMaterial</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#scatteringpattern">ScatteringPattern</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#radio-devices">Radio Devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#transmitter">Transmitter</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#receiver">Receiver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#antenna-arrays">Antenna Arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#antennaarray">AntennaArray</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#planararray">PlanarArray</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#antennas">Antennas</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#antenna">Antenna</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#compute-gain">compute_gain</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#visualize">visualize</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#dipole-pattern">dipole_pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#hw-dipole-pattern">hw_dipole_pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#iso-pattern">iso_pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#tr38901-pattern">tr38901_pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#polarization-model-1">polarization_model_1</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#polarization-model-2">polarization_model_2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rt.html#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="rt.html#cross">cross</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#dot">dot</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#normalize">normalize</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#phi-hat">phi_hat</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#rotate">rotate</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#rotation-matrix">rotation_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#rot-mat-from-unit-vecs">rot_mat_from_unit_vecs</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#r-hat">r_hat</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#sample-points-on-hemisphere">sample_points_on_hemisphere</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#theta-hat">theta_hat</a></li>
<li class="toctree-l4"><a class="reference internal" href="rt.html#theta-phi-from-unit-vec">theta_phi_from_unit_vec</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="signal.html">Signal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="signal.html#filters">Filters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="signal.html#sincfilter">SincFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#raisedcosinefilter">RaisedCosineFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#rootraisedcosinefilter">RootRaisedCosineFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#customfilter">CustomFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#id1">Filter</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="signal.html#window-functions">Window functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="signal.html#hannwindow">HannWindow</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#hammingwindow">HammingWindow</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#blackmanwindow">BlackmanWindow</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#customwindow">CustomWindow</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#id2">Window</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="signal.html#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="signal.html#convolve">convolve</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#fft">fft</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#ifft">ifft</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#upsampling">Upsampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#downsampling">Downsampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#empirical-psd">empirical_psd</a></li>
<li class="toctree-l4"><a class="reference internal" href="signal.html#empirical-aclr">empirical_aclr</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">Utility Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="utils.html#metrics">Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="utils.html#biterrorrate">BitErrorRate</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#bitwisemutualinformation">BitwiseMutualInformation</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#compute-ber">compute_ber</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#compute-bler">compute_bler</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#compute-ser">compute_ser</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#count-errors">count_errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#count-block-errors">count_block_errors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="utils.html#tensors">Tensors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="utils.html#expand-to-rank">expand_to_rank</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#flatten-dims">flatten_dims</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#flatten-last-dims">flatten_last_dims</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#insert-dims">insert_dims</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#split-dims">split_dims</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#matrix-sqrt">matrix_sqrt</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#matrix-sqrt-inv">matrix_sqrt_inv</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#matrix-inv">matrix_inv</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#matrix-pinv">matrix_pinv</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="utils.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l4"><a class="reference internal" href="utils.html#binarysource">BinarySource</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#symbolsource">SymbolSource</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#qamsource">QAMSource</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#pamsource">PAMSource</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#plotber">PlotBER</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#sim-ber">sim_ber</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#ebnodb2no">ebnodb2no</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#hard-decisions">hard_decisions</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#plot-ber">plot_ber</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#complex-normal">complex_normal</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#log2">log2</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils.html#log10">log10</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/NVlabs/sionna/discussions">Discussions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/NVlabs/sionna/issues">Report an Issue</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Sionna</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="sionna.html">API Documentation</a> &raquo;</li>
      <li>Multiple-Input Multiple-Output (MIMO)</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="multiple-input-multiple-output-mimo">
<h1>Multiple-Input Multiple-Output (MIMO)<a class="headerlink" href="#multiple-input-multiple-output-mimo" title="Permalink to this headline"></a></h1>
<p>This module provides layers and functions to support simulation of multicell
MIMO transmissions.</p>
<div class="section" id="stream-management">
<h2>Stream Management<a class="headerlink" href="#stream-management" title="Permalink to this headline"></a></h2>
<p>Stream management determines which transmitter is sending which stream to
which receiver. Transmitters and receivers can be user terminals or base
stations, depending on whether uplink or downlink transmissions are considered.
The <a class="reference internal" href="#sionna.mimo.StreamManagement" title="sionna.mimo.StreamManagement"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamManagement</span></code></a> class has various properties that
are needed to recover desired or interfering channel coefficients for precoding
and equalization. In order to understand how the various properties of
<a class="reference internal" href="#sionna.mimo.StreamManagement" title="sionna.mimo.StreamManagement"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamManagement</span></code></a> can be used, we recommend to have a look
at the source code of the <a class="reference internal" href="ofdm.html#sionna.ofdm.LMMSEEqualizer" title="sionna.ofdm.LMMSEEqualizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">LMMSEEqualizer</span></code></a> or
<a class="reference internal" href="ofdm.html#sionna.ofdm.ZFPrecoder" title="sionna.ofdm.ZFPrecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZFPrecoder</span></code></a>.</p>
<p>The following code snippet shows how to configure
<a class="reference internal" href="#sionna.mimo.StreamManagement" title="sionna.mimo.StreamManagement"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamManagement</span></code></a> for a simple uplink scenario, where
four transmitters send each one stream to a receiver. Note that
<a class="reference internal" href="#sionna.mimo.StreamManagement" title="sionna.mimo.StreamManagement"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamManagement</span></code></a> is independent of the actual number of
antennas at the transmitters and receivers.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">num_tx</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">num_rx</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">num_streams_per_tx</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Indicate which transmitter is associated with which receiver</span>
<span class="c1"># rx_tx_association[i,j] = 1 means that transmitter j sends one</span>
<span class="c1"># or mutiple streams to receiver i.</span>
<span class="n">rx_tx_association</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_rx</span><span class="p">,</span> <span class="n">num_tx</span><span class="p">])</span>
<span class="n">rx_tx_association</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rx_tx_association</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rx_tx_association</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rx_tx_association</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">sm</span> <span class="o">=</span> <span class="n">StreamManagement</span><span class="p">(</span><span class="n">rx_tx_association</span><span class="p">,</span> <span class="n">num_streams_per_tx</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">StreamManagement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rx_tx_association</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_streams_per_tx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/stream_management.html#StreamManagement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.StreamManagement" title="Permalink to this definition"></a></dt>
<dd><p>Class for management of streams in multi-cell MIMO networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rx_tx_association</strong> (<em>[</em><em>num_rx</em><em>, </em><em>num_tx</em><em>]</em><em>, </em><em>np.int</em>) – A binary NumPy array where <code class="docutils literal notranslate"><span class="pre">rx_tx_association[i,j]=1</span></code> means
that receiver <cite>i</cite> gets one or multiple streams from
transmitter <cite>j</cite>.</p></li>
<li><p><strong>num_streams_per_tx</strong> (<em>int</em>) – Indicates the number of streams that are transmitted by each
transmitter.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several symmetry constraints on <code class="docutils literal notranslate"><span class="pre">rx_tx_association</span></code> are imposed
to ensure efficient processing. All row sums and all column sums
must be equal, i.e., all receivers have the same number of associated
transmitters and all transmitters have the same number of associated
receivers. It is also assumed that all transmitters send the same
number of streams <code class="docutils literal notranslate"><span class="pre">num_streams_per_tx</span></code>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.detection_desired_ind">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">detection_desired_ind</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.detection_desired_ind" title="Permalink to this definition"></a></dt>
<dd><p>Indices needed to gather desired channels for receive processing.</p>
<p>A NumPy array of shape <cite>[num_rx*num_streams_per_rx]</cite> that
can be used to gather desired channels from the flattened
channel tensor of shape
<cite>[…,num_rx, num_tx, num_streams_per_tx,…]</cite>.
The result of the gather operation can be reshaped to
<cite>[…,num_rx, num_streams_per_rx,…]</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.detection_undesired_ind">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">detection_undesired_ind</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.detection_undesired_ind" title="Permalink to this definition"></a></dt>
<dd><p>Indices needed to gather undesired channels for receive processing.</p>
<p>A NumPy array of shape <cite>[num_rx*num_streams_per_rx]</cite> that
can be used to gather undesired channels from the flattened
channel tensor of shape <cite>[…,num_rx, num_tx, num_streams_per_tx,…]</cite>.
The result of the gather operation can be reshaped to
<cite>[…,num_rx, num_interfering_streams_per_rx,…]</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_interfering_streams_per_rx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_interfering_streams_per_rx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_interfering_streams_per_rx" title="Permalink to this definition"></a></dt>
<dd><p>Number of interfering streams received at each eceiver.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_rx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_rx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_rx" title="Permalink to this definition"></a></dt>
<dd><p>Number of receivers.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_rx_per_tx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_rx_per_tx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_rx_per_tx" title="Permalink to this definition"></a></dt>
<dd><p>Number of receivers communicating with a transmitter.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_streams_per_rx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_streams_per_rx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_streams_per_rx" title="Permalink to this definition"></a></dt>
<dd><p>Number of streams transmitted to each receiver.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_streams_per_tx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_streams_per_tx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_streams_per_tx" title="Permalink to this definition"></a></dt>
<dd><p>Number of streams per transmitter.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_tx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_tx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_tx" title="Permalink to this definition"></a></dt>
<dd><p>Number of transmitters.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.num_tx_per_rx">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_tx_per_rx</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.num_tx_per_rx" title="Permalink to this definition"></a></dt>
<dd><p>Number of transmitters communicating with a receiver.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.precoding_ind">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">precoding_ind</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.precoding_ind" title="Permalink to this definition"></a></dt>
<dd><p>Indices needed to gather channels for precoding.</p>
<p>A NumPy array of shape <cite>[num_tx, num_rx_per_tx]</cite>,
where <code class="docutils literal notranslate"><span class="pre">precoding_ind[i,:]</span></code> contains the indices of the
receivers to which transmitter <cite>i</cite> is sending streams.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.rx_stream_ids">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">rx_stream_ids</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.rx_stream_ids" title="Permalink to this definition"></a></dt>
<dd><p>Mapping of streams to receivers.</p>
<p>A Numpy array of shape <cite>[num_rx, num_streams_per_rx]</cite>.
This array is obtained from <code class="docutils literal notranslate"><span class="pre">tx_stream_ids</span></code> together with
the <code class="docutils literal notranslate"><span class="pre">rx_tx_association</span></code>. <code class="docutils literal notranslate"><span class="pre">rx_stream_ids[i,:]</span></code> contains
the indices of streams that are supposed to be decoded by receiver <cite>i</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.rx_tx_association">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">rx_tx_association</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.rx_tx_association" title="Permalink to this definition"></a></dt>
<dd><p>Association between receivers and transmitters.</p>
<p>A binary NumPy array of shape <cite>[num_rx, num_tx]</cite>,
where <code class="docutils literal notranslate"><span class="pre">rx_tx_association[i,j]=1</span></code> means that receiver <cite>i</cite>
gets one ore multiple streams from transmitter <cite>j</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.stream_association">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">stream_association</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.stream_association" title="Permalink to this definition"></a></dt>
<dd><p>Association between receivers, transmitters, and streams.</p>
<p>A binary NumPy array of shape
<cite>[num_rx, num_tx, num_streams_per_tx]</cite>, where
<code class="docutils literal notranslate"><span class="pre">stream_association[i,j,k]=1</span></code> means that receiver <cite>i</cite> gets
the <cite>k</cite> th stream from transmitter <cite>j</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.stream_ind">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">stream_ind</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.stream_ind" title="Permalink to this definition"></a></dt>
<dd><p>Indices needed to gather received streams in the correct order.</p>
<p>A NumPy array of shape <cite>[num_rx*num_streams_per_rx]</cite> that can be
used to gather streams from the flattened tensor of received streams
of shape <cite>[…,num_rx, num_streams_per_rx,…]</cite>. The result of the
gather operation is then reshaped to
<cite>[…,num_tx, num_streams_per_tx,…]</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sionna.mimo.StreamManagement.tx_stream_ids">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">tx_stream_ids</span></span><a class="headerlink" href="#sionna.mimo.StreamManagement.tx_stream_ids" title="Permalink to this definition"></a></dt>
<dd><p>Mapping of streams to transmitters.</p>
<p>A NumPy array of shape <cite>[num_tx, num_streams_per_tx]</cite>.
Streams are numbered from 0,1,… and assiged to transmitters in
increasing order, i.e., transmitter 0 gets the first
<cite>num_streams_per_tx</cite> and so on.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="precoding">
<h2>Precoding<a class="headerlink" href="#precoding" title="Permalink to this headline"></a></h2>
<div class="section" id="zero-forcing-precoder">
<h3>zero_forcing_precoder<a class="headerlink" href="#zero-forcing-precoder" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.zero_forcing_precoder">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">zero_forcing_precoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_precoding_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/precoding.html#zero_forcing_precoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.zero_forcing_precoder" title="Permalink to this definition"></a></dt>
<dd><p>Zero-Forcing (ZF) Precoder</p>
<p>This function implements ZF precoding for a MIMO link, assuming the
following model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{G}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^K\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{K\times M}\)</span> is the known channel matrix,
<span class="math notranslate nohighlight">\(\mathbf{G}\in\mathbb{C}^{M\times K}\)</span> is the precoding matrix,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K\)</span> is the symbol vector to be precoded,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^K\)</span> is a noise vector. It is assumed that
<span class="math notranslate nohighlight">\(K\le M\)</span>.</p>
<p>The precoding matrix <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> is defined as (Eq. 4.37) <a class="reference internal" href="channel.wireless.html#bhs2017" id="id1"><span>[BHS2017]</span></a> :</p>
<div class="math notranslate nohighlight">
\[\mathbf{G} = \mathbf{V}\mathbf{D}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{V} &amp;= \mathbf{H}^{\mathsf{H}}\left(\mathbf{H} \mathbf{H}^{\mathsf{H}}\right)^{-1}\\
\mathbf{D} &amp;= \mathop{\text{diag}}\left( \lVert \mathbf{v}_{k} \rVert_2^{-1}, k=0,\dots,K-1 \right).\end{split}\]</div>
<p>This ensures that each stream is precoded with a unit-norm vector,
i.e., <span class="math notranslate nohighlight">\(\mathop{\text{tr}}\left(\mathbf{G}\mathbf{G}^{\mathsf{H}}\right)=K\)</span>.
The function returns the precoded vector <span class="math notranslate nohighlight">\(\mathbf{G}\mathbf{x}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>[…,K], tf.complex</em>) – 1+D tensor containing the symbol vectors to be precoded.</p></li>
<li><p><strong>h</strong> (<em>[…,K,M], tf.complex</em>) – 2+D tensor containing the channel matrices</p></li>
<li><p><strong>return_precoding_matrices</strong> (<em>bool</em>) – Indicates if the precoding matrices should be returned or not.
Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>x_precoded</strong> (<em>[…,M], tf.complex</em>) – Tensor of the same shape and dtype as <code class="docutils literal notranslate"><span class="pre">x</span></code> apart from the last
dimensions that has changed from <cite>K</cite> to <cite>M</cite>. It contains the
precoded symbol vectors.</p></li>
<li><p><strong>g</strong> (<em>[…,M,K], tf.complex</em>) – 2+D tensor containing the precoding matrices. It is only returned
if <code class="docutils literal notranslate"><span class="pre">return_precoding_matrices=True</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this function in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you must set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="equalization">
<h2>Equalization<a class="headerlink" href="#equalization" title="Permalink to this headline"></a></h2>
<div class="section" id="lmmse-equalizer">
<h3>lmmse_equalizer<a class="headerlink" href="#lmmse-equalizer" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.lmmse_equalizer">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">lmmse_equalizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whiten_interference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/equalization.html#lmmse_equalizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.lmmse_equalizer" title="Permalink to this definition"></a></dt>
<dd><p>MIMO LMMSE Equalizer</p>
<p>This function implements LMMSE equalization for a MIMO link, assuming the
following model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K\)</span> is the vector of transmitted symbols,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{x}\right]=\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{x}\mathbf{x}^{\mathsf{H}}\right]=\mathbf{I}_K\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>.</p>
<p>The estimated symbol vector <span class="math notranslate nohighlight">\(\hat{\mathbf{x}}\in\mathbb{C}^K\)</span> is given as
(Lemma B.19) <a class="reference internal" href="channel.wireless.html#bhs2017" id="id2"><span>[BHS2017]</span></a> :</p>
<div class="math notranslate nohighlight">
\[\hat{\mathbf{x}} = \mathop{\text{diag}}\left(\mathbf{G}\mathbf{H}\right)^{-1}\mathbf{G}\mathbf{y}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\mathbf{G} = \mathbf{H}^{\mathsf{H}} \left(\mathbf{H}\mathbf{H}^{\mathsf{H}} + \mathbf{S}\right)^{-1}.\]</div>
<p>This leads to the post-equalized per-symbol model:</p>
<div class="math notranslate nohighlight">
\[\hat{x}_k = x_k + e_k,\quad k=0,\dots,K-1\]</div>
<p>where the variances <span class="math notranslate nohighlight">\(\sigma^2_k\)</span> of the effective residual noise
terms <span class="math notranslate nohighlight">\(e_k\)</span> are given by the diagonal elements of</p>
<div class="math notranslate nohighlight">
\[\mathop{\text{diag}}\left(\mathbb{E}\left[\mathbf{e}\mathbf{e}^{\mathsf{H}}\right]\right)
= \mathop{\text{diag}}\left(\mathbf{G}\mathbf{H} \right)^{-1} - \mathbf{I}.\]</div>
<p>Note that the scaling by <span class="math notranslate nohighlight">\(\mathop{\text{diag}}\left(\mathbf{G}\mathbf{H}\right)^{-1}\)</span>
is important for the <a class="reference internal" href="mapping.html#sionna.mapping.Demapper" title="sionna.mapping.Demapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demapper</span></code></a> although it does
not change the signal-to-noise ratio.</p>
<p>The function returns <span class="math notranslate nohighlight">\(\hat{\mathbf{x}}\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{\sigma}^2=\left[\sigma^2_0,\dots, \sigma^2_{K-1}\right]^{\mathsf{T}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,K], tf.complex</em>) – 2+D tensor containing the channel matrices.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
<li><p><strong>whiten_interference</strong> (<em>bool</em>) – If <cite>True</cite> (default), the interference is first whitened before equalization.
In this case, an alternative expression for the receive filter is used that
can be numerically more stable. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>x_hat</strong> (<em>[…,K], tf.complex</em>) – 1+D tensor representing the estimated symbol vectors.</p></li>
<li><p><strong>no_eff</strong> (<em>tf.float</em>) – Tensor of the same shape as <code class="docutils literal notranslate"><span class="pre">x_hat</span></code> containing the effective noise
variance estimates.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this function in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you must set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="mf-equalizer">
<h3>mf_equalizer<a class="headerlink" href="#mf-equalizer" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.mf_equalizer">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">mf_equalizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/equalization.html#mf_equalizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.mf_equalizer" title="Permalink to this definition"></a></dt>
<dd><p>MIMO MF Equalizer</p>
<p>This function implements matched filter (MF) equalization for a
MIMO link, assuming the following model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K\)</span> is the vector of transmitted symbols,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{x}\right]=\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{x}\mathbf{x}^{\mathsf{H}}\right]=\mathbf{I}_K\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>.</p>
<p>The estimated symbol vector <span class="math notranslate nohighlight">\(\hat{\mathbf{x}}\in\mathbb{C}^K\)</span> is given as
(Eq. 4.11) <a class="reference internal" href="channel.wireless.html#bhs2017" id="id3"><span>[BHS2017]</span></a> :</p>
<div class="math notranslate nohighlight">
\[\hat{\mathbf{x}} = \mathbf{G}\mathbf{y}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\mathbf{G} = \mathop{\text{diag}}\left(\mathbf{H}^{\mathsf{H}}\mathbf{H}\right)^{-1}\mathbf{H}^{\mathsf{H}}.\]</div>
<p>This leads to the post-equalized per-symbol model:</p>
<div class="math notranslate nohighlight">
\[\hat{x}_k = x_k + e_k,\quad k=0,\dots,K-1\]</div>
<p>where the variances <span class="math notranslate nohighlight">\(\sigma^2_k\)</span> of the effective residual noise
terms <span class="math notranslate nohighlight">\(e_k\)</span> are given by the diagonal elements of the matrix</p>
<div class="math notranslate nohighlight">
\[\mathbb{E}\left[\mathbf{e}\mathbf{e}^{\mathsf{H}}\right]
= \left(\mathbf{I}-\mathbf{G}\mathbf{H} \right)\left(\mathbf{I}-\mathbf{G}\mathbf{H} \right)^{\mathsf{H}} + \mathbf{G}\mathbf{S}\mathbf{G}^{\mathsf{H}}.\]</div>
<p>Note that the scaling by <span class="math notranslate nohighlight">\(\mathop{\text{diag}}\left(\mathbf{H}^{\mathsf{H}}\mathbf{H}\right)^{-1}\)</span>
in the definition of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span>
is important for the <a class="reference internal" href="mapping.html#sionna.mapping.Demapper" title="sionna.mapping.Demapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demapper</span></code></a> although it does
not change the signal-to-noise ratio.</p>
<p>The function returns <span class="math notranslate nohighlight">\(\hat{\mathbf{x}}\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{\sigma}^2=\left[\sigma^2_0,\dots, \sigma^2_{K-1}\right]^{\mathsf{T}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,K], tf.complex</em>) – 2+D tensor containing the channel matrices.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>x_hat</strong> (<em>[…,K], tf.complex</em>) – 1+D tensor representing the estimated symbol vectors.</p></li>
<li><p><strong>no_eff</strong> (<em>tf.float</em>) – Tensor of the same shape as <code class="docutils literal notranslate"><span class="pre">x_hat</span></code> containing the effective noise
variance estimates.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="zf-equalizer">
<h3>zf_equalizer<a class="headerlink" href="#zf-equalizer" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.zf_equalizer">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">zf_equalizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/equalization.html#zf_equalizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.zf_equalizer" title="Permalink to this definition"></a></dt>
<dd><p>MIMO ZF Equalizer</p>
<p>This function implements zero-forcing (ZF) equalization for a MIMO link, assuming the
following model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K\)</span> is the vector of transmitted symbols,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{x}\right]=\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{x}\mathbf{x}^{\mathsf{H}}\right]=\mathbf{I}_K\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>.</p>
<p>The estimated symbol vector <span class="math notranslate nohighlight">\(\hat{\mathbf{x}}\in\mathbb{C}^K\)</span> is given as
(Eq. 4.10) <a class="reference internal" href="channel.wireless.html#bhs2017" id="id4"><span>[BHS2017]</span></a> :</p>
<div class="math notranslate nohighlight">
\[\hat{\mathbf{x}} = \mathbf{G}\mathbf{y}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\mathbf{G} = \left(\mathbf{H}^{\mathsf{H}}\mathbf{H}\right)^{-1}\mathbf{H}^{\mathsf{H}}.\]</div>
<p>This leads to the post-equalized per-symbol model:</p>
<div class="math notranslate nohighlight">
\[\hat{x}_k = x_k + e_k,\quad k=0,\dots,K-1\]</div>
<p>where the variances <span class="math notranslate nohighlight">\(\sigma^2_k\)</span> of the effective residual noise
terms <span class="math notranslate nohighlight">\(e_k\)</span> are given by the diagonal elements of the matrix</p>
<div class="math notranslate nohighlight">
\[\mathbb{E}\left[\mathbf{e}\mathbf{e}^{\mathsf{H}}\right]
= \mathbf{G}\mathbf{S}\mathbf{G}^{\mathsf{H}}.\]</div>
<p>The function returns <span class="math notranslate nohighlight">\(\hat{\mathbf{x}}\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol{\sigma}^2=\left[\sigma^2_0,\dots, \sigma^2_{K-1}\right]^{\mathsf{T}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,K], tf.complex</em>) – 2+D tensor containing the channel matrices.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>x_hat</strong> (<em>[…,K], tf.complex</em>) – 1+D tensor representing the estimated symbol vectors.</p></li>
<li><p><strong>no_eff</strong> (<em>tf.float</em>) – Tensor of the same shape as <code class="docutils literal notranslate"><span class="pre">x_hat</span></code> containing the effective noise
variance estimates.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this function in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you must set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="detection">
<h2>Detection<a class="headerlink" href="#detection" title="Permalink to this headline"></a></h2>
<div class="section" id="epdetector">
<h3>EPDetector<a class="headerlink" href="#epdetector" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.EPDetector">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">EPDetector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tf.complex64</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/detection.html#EPDetector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.EPDetector" title="Permalink to this definition"></a></dt>
<dd><p>MIMO Expectation Propagation (EP) detector</p>
<p>This layer implements Expectation Propagation (EP) MIMO detection as described
in <a class="reference internal" href="#ep2014" id="id5"><span>[EP2014]</span></a>. It can generate hard- or soft-decisions for symbols or bits.</p>
<p>This layer assumes the following channel model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathcal{C}^S\)</span> is the vector of transmitted symbols which
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times S}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a complex Gaussian noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> has full rank.</p>
<p>The channel model is first whitened using <a class="reference internal" href="#sionna.mimo.whiten_channel" title="sionna.mimo.whiten_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">whiten_channel()</span></code></a>
and then converted to its real-valued equivalent,
see <a class="reference internal" href="#sionna.mimo.complex2real_channel" title="sionna.mimo.complex2real_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex2real_channel()</span></code></a>, prior to MIMO detection.</p>
<p>The computation of LLRs is done by converting the symbol logits
that naturally arise in the algorithm to LLRs using
<a class="reference internal" href="mapping.html#sionna.mapping.PAM2QAM" title="sionna.mapping.PAM2QAM"><code class="xref py py-func docutils literal notranslate"><span class="pre">PAM2QAM()</span></code></a>. Custom conversions of symbol logits to LLRs
can be implemented by using the soft-symbol output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> (<em>One of</em><em> [</em><em>&quot;bit&quot;</em><em>, </em><em>&quot;symbol&quot;</em><em>]</em><em>, </em><em>str</em>) – The type of output, either bits or symbols. Whether soft- or
hard-decisions are returned can be configured with the
<code class="docutils literal notranslate"><span class="pre">hard_out</span></code> flag.</p></li>
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – The number of bits per QAM constellation symbol, e.g., 4 for QAM16.</p></li>
<li><p><strong>hard_out</strong> (<em>bool</em>) – If <cite>True</cite>, the detector computes hard-decided bit values or
constellation point indices instead of soft-values.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>l</strong> (<em>int</em>) – Number of iterations. Defaults to 10.</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – Parameter <span class="math notranslate nohighlight">\(\beta\in[0,1]\)</span> for update smoothing.
Defaults to 0.9.</p></li>
<li><p><strong>dtype</strong> (<em>One of</em><em> [</em><em>tf.complex64</em><em>, </em><em>tf.complex128</em><em>] </em><em>tf.DType</em><em> (</em><em>dtype</em><em>)</em>) – Precision used for internal computations. Defaults to <code class="docutils literal notranslate"><span class="pre">tf.complex64</span></code>.
Especially for large MIMO setups, the precision can make a significant
performance difference.</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, h, s)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals</p></li>
<li><p><strong>h</strong> (<em>[…,M,num_streams], tf.complex</em>) – 2+D tensor containing the channel matrices</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>One of</strong></p></li>
<li><p><em>[…,num_streams,num_bits_per_symbol], tf.float</em> – LLRs or hard-decisions for every bit of every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“bit”</cite></p></li>
<li><p><em>[…,num_streams,2**num_bits_per_symbol], tf.float or […,num_streams], tf.int</em> – Logits or hard-decisions for constellation symbols for every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“symbol”</cite></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For numerical stability, we do not recommend to use this function in Graph
mode with XLA, i.e., within a function that is decorated with
<code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>.
However, it is possible to do so by setting
<code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="kbestdetector">
<h3>KBestDetector<a class="headerlink" href="#kbestdetector" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.KBestDetector">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">KBestDetector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_streams</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_real_rep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list2llr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tf.complex64</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/detection.html#KBestDetector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.KBestDetector" title="Permalink to this definition"></a></dt>
<dd><p>MIMO K-Best detector</p>
<p>This layer implements K-Best MIMO detection as described
in (Eq. 4-5) <a class="reference internal" href="#ft2015" id="id6"><span>[FT2015]</span></a>. It can either generate hard decisions (for symbols
or bits) or compute LLRs.</p>
<p>The algorithm operates in either the complex or real-valued domain.
Although both options produce identical results, the former has the advantage
that it can be applied to arbitrary non-QAM constellations. It also reduces
the number of streams (or depth) by a factor of two.</p>
<p>The way soft-outputs (i.e., LLRs) are computed is determined by the
<code class="docutils literal notranslate"><span class="pre">list2llr</span></code> function. The default solution
<a class="reference internal" href="#sionna.mimo.List2LLRSimple" title="sionna.mimo.List2LLRSimple"><code class="xref py py-class docutils literal notranslate"><span class="pre">List2LLRSimple</span></code></a> assigns a predetermined
value to all LLRs without counter-hypothesis.</p>
<p>This layer assumes the following channel model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathcal{C}^S\)</span> is the vector of transmitted symbols which
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times S}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a complex Gaussian noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> has full rank.</p>
<p>In a first optional step, the channel model is converted to its real-valued equivalent,
see <a class="reference internal" href="#sionna.mimo.complex2real_channel" title="sionna.mimo.complex2real_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex2real_channel()</span></code></a>. We assume in the sequel the complex-valued
representation. Then, the channel is whitened using <a class="reference internal" href="#sionna.mimo.whiten_channel" title="sionna.mimo.whiten_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">whiten_channel()</span></code></a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{\mathbf{y}} &amp;= \mathbf{S}^{-\frac{1}{2}}\mathbf{y}\\
&amp;=  \mathbf{S}^{-\frac{1}{2}}\mathbf{H}\mathbf{x} + \mathbf{S}^{-\frac{1}{2}}\mathbf{n}\\
&amp;= \tilde{\mathbf{H}}\mathbf{x} + \tilde{\mathbf{n}}.\end{split}\]</div>
<p>Next, the columns of <span class="math notranslate nohighlight">\(\tilde{\mathbf{H}}\)</span> are sorted according
to their norm in descending order. Then, the QR decomposition of the
resulting channel matrix is computed:</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{H}} = \mathbf{Q}\mathbf{R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{Q}\in\mathbb{C}^{M\times S}\)</span> is unitary and
<span class="math notranslate nohighlight">\(\mathbf{R}\in\mathbb{C}^{S\times S}\)</span> is upper-triangular.
The channel outputs are then pre-multiplied by <span class="math notranslate nohighlight">\(\mathbf{Q}^{\mathsf{H}}\)</span>.
This leads to the final channel model on which the K-Best detection algorithm operates:</p>
<div class="math notranslate nohighlight">
\[\bar{\mathbf{y}} = \mathbf{R}\bar{\mathbf{x}} + \bar{\mathbf{n}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{\mathbf{y}}\in\mathbb{C}^S\)</span>,
<span class="math notranslate nohighlight">\(\bar{\mathbf{x}}\in\mathbb{C}^S\)</span>, and <span class="math notranslate nohighlight">\(\bar{\mathbf{n}}\in\mathbb{C}^S\)</span>
with <span class="math notranslate nohighlight">\(\mathbb{E}\left[\bar{\mathbf{n}}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\bar{\mathbf{n}}\bar{\mathbf{n}}^{\mathsf{H}}\right]=\mathbf{I}\)</span>.</p>
<p><strong>LLR Computation</strong></p>
<p>The K-Best algorithm produces <span class="math notranslate nohighlight">\(K\)</span> candidate solutions <span class="math notranslate nohighlight">\(\bar{\mathbf{x}}_k\in\mathcal{C}^S\)</span>
and their associated distance metrics <span class="math notranslate nohighlight">\(d_k=\lVert \bar{\mathbf{y}} - \mathbf{R}\bar{\mathbf{x}}_k \rVert^2\)</span>
for <span class="math notranslate nohighlight">\(k=1,\dots,K\)</span>. If the real-valued channel representation is used, the distance
metrics are scaled by 0.5 to account for the reduced noise power in each complex dimension.
A hard-decision is simply the candidate with the shortest distance.
Various ways to compute LLRs from this list (and possibly
additional side-information) are possible. The (sub-optimal) default solution
is <a class="reference internal" href="#sionna.mimo.List2LLRSimple" title="sionna.mimo.List2LLRSimple"><code class="xref py py-class docutils literal notranslate"><span class="pre">List2LLRSimple</span></code></a>. Custom solutions can be provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> (<em>One of</em><em> [</em><em>&quot;bit&quot;</em><em>, </em><em>&quot;symbol&quot;</em><em>]</em><em>, </em><em>str</em>) – The type of output, either bits or symbols. Whether soft- or
hard-decisions are returned can be configured with the
<code class="docutils literal notranslate"><span class="pre">hard_out</span></code> flag.</p></li>
<li><p><strong>num_streams</strong> (<em>tf.int</em>) – Number of transmitted streams</p></li>
<li><p><strong>k</strong> (<em>tf.int</em>) – The number of paths to keep. Cannot be larger than the
number of constellation points to the power of the number of
streams.</p></li>
<li><p><strong>constellation_type</strong> (<em>One of</em><em> [</em><em>&quot;qam&quot;</em><em>, </em><em>&quot;pam&quot;</em><em>, </em><em>&quot;custom&quot;</em><em>]</em><em>, </em><em>str</em>) – For “custom”, an instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a>
must be provided.</p></li>
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – The number of bits per constellation symbol, e.g., 4 for QAM16.
Only required for <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code> in [“qam”, “pam”].</p></li>
<li><p><strong>constellation</strong> (<a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><em>Constellation</em></a>) – An instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a> or <cite>None</cite>.
In the latter case, <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code>
and <code class="docutils literal notranslate"><span class="pre">num_bits_per_symbol</span></code> must be provided.</p></li>
<li><p><strong>hard_out</strong> (<em>bool</em>) – If <cite>True</cite>, the detector computes hard-decided bit values or
constellation point indices instead of soft-values.
Defaults to <cite>False</cite>. The detector cannot compute soft-symbols.</p></li>
<li><p><strong>use_real_rep</strong> (<em>bool</em>) – If <cite>True</cite>, the detector use the real-valued equivalent representation
of the channel. Note that this only works with a QAM constellation.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>list2llr</strong> (<cite>None</cite> or instance of <a class="reference internal" href="#sionna.mimo.List2LLR" title="sionna.mimo.List2LLR"><code class="xref py py-class docutils literal notranslate"><span class="pre">List2LLR</span></code></a>) – The function to be used to compute LLRs from a list of candidate solutions.
If <cite>None</cite>, the default solution <a class="reference internal" href="#sionna.mimo.List2LLRSimple" title="sionna.mimo.List2LLRSimple"><code class="xref py py-class docutils literal notranslate"><span class="pre">List2LLRSimple</span></code></a>
is used.</p></li>
<li><p><strong>dtype</strong> (<em>One of</em><em> [</em><em>tf.complex64</em><em>, </em><em>tf.complex128</em><em>] </em><em>tf.DType</em><em> (</em><em>dtype</em><em>)</em>) – The dtype of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Defaults to tf.complex64.
The output dtype is the corresponding real dtype (tf.float32 or tf.float64).</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, h, s)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals</p></li>
<li><p><strong>h</strong> (<em>[…,M,num_streams], tf.complex</em>) – 2+D tensor containing the channel matrices</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>One of</strong></p></li>
<li><p><em>[…,num_streams,num_bits_per_symbol], tf.float</em> – LLRs or hard-decisions for every bit of every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“bit”</cite></p></li>
<li><p><em>[…,num_streams,2**num_points], tf.float or […,num_streams], tf.int</em> – Logits or hard-decisions for constellation symbols for every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“symbol”</cite>
Hard-decisions correspond to the symbol indices.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this layer in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you must set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="lineardetector">
<h3>LinearDetector<a class="headerlink" href="#lineardetector" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.LinearDetector">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">LinearDetector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">equalizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demapping_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tf.complex64</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/detection.html#LinearDetector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.LinearDetector" title="Permalink to this definition"></a></dt>
<dd><p>Convenience class that combines an equalizer,
such as <a class="reference internal" href="#sionna.mimo.lmmse_equalizer" title="sionna.mimo.lmmse_equalizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">lmmse_equalizer()</span></code></a>, and a <a class="reference internal" href="mapping.html#sionna.mapping.Demapper" title="sionna.mapping.Demapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demapper</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>equalizer</strong> (<em>str</em><em>, </em><em>one of</em><em> [</em><em>&quot;lmmse&quot;</em><em>, </em><em>&quot;zf&quot;</em><em>, </em><em>&quot;mf&quot;</em><em>]</em><em>, or </em><em>an equalizer function</em>) – The equalizer to be used. Either one of the existing equalizers
<a class="reference internal" href="#sionna.mimo.lmmse_equalizer" title="sionna.mimo.lmmse_equalizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">lmmse_equalizer()</span></code></a>, <a class="reference internal" href="#sionna.mimo.zf_equalizer" title="sionna.mimo.zf_equalizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">zf_equalizer()</span></code></a>, or
<a class="reference internal" href="#sionna.mimo.mf_equalizer" title="sionna.mimo.mf_equalizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">mf_equalizer()</span></code></a> can be used, or a custom equalizer
callable provided that has the same input/output specification.</p></li>
<li><p><strong>output</strong> (<em>One of</em><em> [</em><em>&quot;bit&quot;</em><em>, </em><em>&quot;symbol&quot;</em><em>]</em><em>, </em><em>str</em>) – The type of output, either LLRs on bits or logits on constellation symbols.</p></li>
<li><p><strong>demapping_method</strong> (<em>One of</em><em> [</em><em>&quot;app&quot;</em><em>, </em><em>&quot;maxlog&quot;</em><em>]</em><em>, </em><em>str</em>) – The demapping method used.</p></li>
<li><p><strong>constellation_type</strong> (<em>One of</em><em> [</em><em>&quot;qam&quot;</em><em>, </em><em>&quot;pam&quot;</em><em>, </em><em>&quot;custom&quot;</em><em>]</em><em>, </em><em>str</em>) – For “custom”, an instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a>
must be provided.</p></li>
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – The number of bits per constellation symbol, e.g., 4 for QAM16.
Only required for <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code> in [“qam”, “pam”].</p></li>
<li><p><strong>constellation</strong> (<a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><em>Constellation</em></a>) – An instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a> or <cite>None</cite>.
In the latter case, <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code>
and <code class="docutils literal notranslate"><span class="pre">num_bits_per_symbol</span></code> must be provided.</p></li>
<li><p><strong>hard_out</strong> (<em>bool</em>) – If <cite>True</cite>, the detector computes hard-decided bit values or
constellation point indices instead of soft-values.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>One of</em><em> [</em><em>tf.complex64</em><em>, </em><em>tf.complex128</em><em>] </em><em>tf.DType</em><em> (</em><em>dtype</em><em>)</em>) – The dtype of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Defaults to tf.complex64.
The output dtype is the corresponding real dtype (tf.float32 or tf.float64).</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, h, s)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals</p></li>
<li><p><strong>h</strong> (<em>[…,M,num_streams], tf.complex</em>) – 2+D tensor containing the channel matrices</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>One of</strong></p></li>
<li><p><em>[…, num_streams, num_bits_per_symbol], tf.float</em> – LLRs or hard-decisions for every bit of every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“bit”</cite></p></li>
<li><p><em>[…, num_streams, num_points], tf.float or […, num_streams], tf.int</em> – Logits or hard-decisions for constellation symbols for every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“symbol”</cite>
Hard-decisions correspond to the symbol indices.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this layer in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you might need to set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>. This depends on the
chosen equalizer function. See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="maximumlikelihooddetector">
<h3>MaximumLikelihoodDetector<a class="headerlink" href="#maximumlikelihooddetector" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.MaximumLikelihoodDetector">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">MaximumLikelihoodDetector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demapping_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_streams</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_prior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tf.complex64</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/detection.html#MaximumLikelihoodDetector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.MaximumLikelihoodDetector" title="Permalink to this definition"></a></dt>
<dd><p>MIMO maximum-likelihood (ML) detector.
If the <code class="docutils literal notranslate"><span class="pre">with_prior</span></code> flag is set, prior knowledge on the bits or constellation points is assumed to be available.</p>
<p>This layer implements MIMO maximum-likelihood (ML) detection assuming the
following channel model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathcal{C}^K\)</span> is the vector of transmitted symbols which
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a complex Gaussian noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> has full rank.
If the <code class="docutils literal notranslate"><span class="pre">with_prior</span></code> flag is set, it is assumed that prior information of the transmitted signal <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is available,
provided either as LLRs on the bits mapped onto <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> or as logits on the individual
constellation points forming <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p>
<p>Prior to demapping, the received signal is whitened:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{\mathbf{y}} &amp;= \mathbf{S}^{-\frac{1}{2}}\mathbf{y}\\
&amp;=  \mathbf{S}^{-\frac{1}{2}}\mathbf{H}\mathbf{x} + \mathbf{S}^{-\frac{1}{2}}\mathbf{n}\\
&amp;= \tilde{\mathbf{H}}\mathbf{x} + \tilde{\mathbf{n}}\end{split}\]</div>
<p>The layer can compute ML detection of symbols or bits with either
soft- or hard-decisions. Note that decisions are computed symbol-/bit-wise
and not jointly for the entire vector <span class="math notranslate nohighlight">\(\textbf{x}\)</span> (or the underlying vector
of bits).</p>
<p><strong>ML detection of bits:</strong></p>
<p>Soft-decisions on bits are called log-likelihood ratios (LLR).
With the “app” demapping method, the LLR for the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user is then computed according to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    LLR(k,i)&amp;= \ln\left(\frac{\Pr\left(b_{k,i}=1\lvert \mathbf{y},\mathbf{H}\right)}{\Pr\left(b_{k,i}=0\lvert \mathbf{y},\mathbf{H}\right)}\right)\\
            &amp;=\ln\left(\frac{
            \sum_{\mathbf{x}\in\mathcal{C}_{k,i,1}} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right) \Pr\left( \mathbf{x} \right)
            }{
            \sum_{\mathbf{x}\in\mathcal{C}_{k,i,0}} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right) \Pr\left( \mathbf{x} \right)
            }\right)
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,1}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,0}\)</span> are the
sets of vectors of constellation points for which the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user is equal to 1 and 0, respectively.
<span class="math notranslate nohighlight">\(\Pr\left( \mathbf{x} \right)\)</span> is the prior distribution of the vector of
constellation points <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. Assuming that the constellation points and
bit levels are independent, it is computed from the prior of the bits according to</p>
<div class="math notranslate nohighlight">
\[\Pr\left( \mathbf{x} \right) = \prod_{k=1}^K \prod_{i=1}^{I} \sigma \left( LLR_p(k,i) \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(LLR_p(k,i)\)</span> is the prior knowledge of the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit of the
<span class="math notranslate nohighlight">\(k\text{th}\)</span> user given as an LLR and which is set to <span class="math notranslate nohighlight">\(0\)</span> if no prior knowledge is assumed to be available,
and <span class="math notranslate nohighlight">\(\sigma\left(\cdot\right)\)</span> is the sigmoid function.
The definition of the LLR has been chosen such that it is equivalent with that of logit. This is
different from many textbooks in communications, where the LLR is
defined as <span class="math notranslate nohighlight">\(LLR(k,i) = \ln\left(\frac{\Pr\left(b_{k,i}=0\lvert \mathbf{y},\mathbf{H}\right)}{\Pr\left(b_{k,i}=1\lvert \mathbf{y},\mathbf{H}\right)}\right)\)</span>.</p>
<p>With the “maxlog” demapping method, the LLR for the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user is approximated like</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    LLR(k,i) \approx&amp;\ln\left(\frac{
        \max_{\mathbf{x}\in\mathcal{C}_{k,i,1}} \left( \exp\left(
            -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
            \right) \Pr\left( \mathbf{x} \right) \right)
        }{
        \max_{\mathbf{x}\in\mathcal{C}_{k,i,0}} \left( \exp\left(
            -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
            \right) \Pr\left( \mathbf{x} \right) \right)
        }\right)\\
        = &amp;\min_{\mathbf{x}\in\mathcal{C}_{k,i,0}} \left( \left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2 - \ln \left(\Pr\left( \mathbf{x} \right) \right) \right) -
            \min_{\mathbf{x}\in\mathcal{C}_{k,i,1}} \left( \left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2 - \ln \left( \Pr\left( \mathbf{x} \right) \right) \right).
    \end{align}\end{split}\]</div>
<p><strong>ML detection of symbols:</strong></p>
<p>Soft-decisions on symbols are called logits (i.e., unnormalized log-probability).</p>
<p>With the “app” demapping method, the logit for the
constellation point <span class="math notranslate nohighlight">\(c \in \mathcal{C}\)</span> of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user  is computed according to</p>
<div class="math notranslate nohighlight">
\[\begin{align}
    \text{logit}(k,c) &amp;= \ln\left(\sum_{\mathbf{x} : x_k = c} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right)\Pr\left( \mathbf{x} \right)\right).
\end{align}\]</div>
<p>With the “maxlog” demapping method, the logit for the constellation point <span class="math notranslate nohighlight">\(c \in \mathcal{C}\)</span>
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user  is approximated like</p>
<div class="math notranslate nohighlight">
\[\text{logit}(k,c) \approx \max_{\mathbf{x} : x_k = c} \left(
        -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2 + \ln \left( \Pr\left( \mathbf{x} \right) \right)
        \right).\]</div>
<p>When hard decisions are requested, this layer returns for the <span class="math notranslate nohighlight">\(k\)</span> th stream</p>
<div class="math notranslate nohighlight">
\[\hat{c}_k = \underset{c \in \mathcal{C}}{\text{argmax}} \left( \sum_{\mathbf{x} : x_k = c} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right)\Pr\left( \mathbf{x} \right) \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> is the set of constellation points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> (<em>One of</em><em> [</em><em>&quot;bit&quot;</em><em>, </em><em>&quot;symbol&quot;</em><em>]</em><em>, </em><em>str</em>) – The type of output, either LLRs on bits or logits on constellation symbols.</p></li>
<li><p><strong>demapping_method</strong> (<em>One of</em><em> [</em><em>&quot;app&quot;</em><em>, </em><em>&quot;maxlog&quot;</em><em>]</em><em>, </em><em>str</em>) – The demapping method used.</p></li>
<li><p><strong>num_streams</strong> (<em>tf.int</em>) – Number of transmitted streams</p></li>
<li><p><strong>constellation_type</strong> (<em>One of</em><em> [</em><em>&quot;qam&quot;</em><em>, </em><em>&quot;pam&quot;</em><em>, </em><em>&quot;custom&quot;</em><em>]</em><em>, </em><em>str</em>) – For “custom”, an instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a>
must be provided.</p></li>
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – The number of bits per constellation symbol, e.g., 4 for QAM16.
Only required for <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code> in [“qam”, “pam”].</p></li>
<li><p><strong>constellation</strong> (<a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><em>Constellation</em></a>) – An instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a> or <cite>None</cite>.
In the latter case, <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code>
and <code class="docutils literal notranslate"><span class="pre">num_bits_per_symbol</span></code> must be provided.</p></li>
<li><p><strong>hard_out</strong> (<em>bool</em>) – If <cite>True</cite>, the detector computes hard-decided bit values or
constellation point indices instead of soft-values.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>with_prior</strong> (<em>bool</em>) – If <cite>True</cite>, it is assumed that prior knowledge on the bits or constellation points is available.
This prior information is given as LLRs (for bits) or log-probabilities (for constellation points) as an
additional input to the layer.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>One of</em><em> [</em><em>tf.complex64</em><em>, </em><em>tf.complex128</em><em>] </em><em>tf.DType</em><em> (</em><em>dtype</em><em>)</em>) – The dtype of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Defaults to tf.complex64.
The output dtype is the corresponding real dtype (tf.float32 or tf.float64).</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, h, s) or (y, h, prior, s)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,num_streams], tf.complex</em>) – 2+D tensor containing the channel matrices.</p></li>
<li><p><strong>prior</strong> (<em>[…,num_streams,num_bits_per_symbol] or […,num_streams,num_points], tf.float</em>) – Prior of the transmitted signals.
If <code class="docutils literal notranslate"><span class="pre">output</span></code> equals “bit”, then LLRs of the transmitted bits are expected.
If <code class="docutils literal notranslate"><span class="pre">output</span></code> equals “symbol”, then logits of the transmitted constellation points are expected.
Only required if the <code class="docutils literal notranslate"><span class="pre">with_prior</span></code> flag is set.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>One of</strong></p></li>
<li><p><em>[…, num_streams, num_bits_per_symbol], tf.float</em> – LLRs or hard-decisions for every bit of every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“bit”</cite>.</p></li>
<li><p><em>[…, num_streams, num_points], tf.float or […, num_streams], tf.int</em> – Logits or hard-decisions for constellation symbols for every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“symbol”</cite>.
Hard-decisions correspond to the symbol indices.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this layer in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you must set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="maximumlikelihooddetectorwithprior">
<h3>MaximumLikelihoodDetectorWithPrior<a class="headerlink" href="#maximumlikelihooddetectorwithprior" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.MaximumLikelihoodDetectorWithPrior">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">MaximumLikelihoodDetectorWithPrior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demapping_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_streams</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tf.complex64</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/detection.html#MaximumLikelihoodDetectorWithPrior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.MaximumLikelihoodDetectorWithPrior" title="Permalink to this definition"></a></dt>
<dd><p>MIMO maximum-likelihood (ML) detector, assuming prior
knowledge on the bits or constellation points is available.</p>
<p>This class is deprecated as the functionality has been integrated
into <a class="reference internal" href="#sionna.mimo.MaximumLikelihoodDetector" title="sionna.mimo.MaximumLikelihoodDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaximumLikelihoodDetector</span></code></a>.</p>
<p>This layer implements MIMO maximum-likelihood (ML) detection assuming the
following channel model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathcal{C}^K\)</span> is the vector of transmitted symbols which
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a complex Gaussian noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> has full rank.
It is assumed that prior information of the transmitted signal <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is available,
provided either as LLRs on the bits modulated onto <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> or as logits on the individual
constellation points forming <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p>
<p>Prior to demapping, the received signal is whitened:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{\mathbf{y}} &amp;= \mathbf{S}^{-\frac{1}{2}}\mathbf{y}\\
&amp;=  \mathbf{S}^{-\frac{1}{2}}\mathbf{H}\mathbf{x} + \mathbf{S}^{-\frac{1}{2}}\mathbf{n}\\
&amp;= \tilde{\mathbf{H}}\mathbf{x} + \tilde{\mathbf{n}}\end{split}\]</div>
<p>The layer can compute ML detection of symbols or bits with either
soft- or hard-decisions. Note that decisions are computed symbol-/bit-wise
and not jointly for the entire vector <span class="math notranslate nohighlight">\(\textbf{x}\)</span> (or the underlying vector
of bits).</p>
<p><strong>ML detection of bits:</strong></p>
<p>Soft-decisions on bits are called log-likelihood ratios (LLR).
With the “app” demapping method, the LLR for the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user is then computed according to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    LLR(k,i)&amp;= \ln\left(\frac{\Pr\left(b_{k,i}=1\lvert \mathbf{y},\mathbf{H}\right)}{\Pr\left(b_{k,i}=0\lvert \mathbf{y},\mathbf{H}\right)}\right)\\
            &amp;=\ln\left(\frac{
            \sum_{\mathbf{x}\in\mathcal{C}_{k,i,1}} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right) \Pr\left( \mathbf{x} \right)
            }{
            \sum_{\mathbf{x}\in\mathcal{C}_{k,i,0}} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right) \Pr\left( \mathbf{x} \right)
            }\right)
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,1}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,0}\)</span> are the
sets of vectors of constellation points for which the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user is equal to 1 and 0, respectively.
<span class="math notranslate nohighlight">\(\Pr\left( \mathbf{x} \right)\)</span> is the prior distribution of the vector of
constellation points <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. Assuming that the constellation points and
bit levels are independent, it is computed from the prior of the bits according to</p>
<div class="math notranslate nohighlight">
\[\Pr\left( \mathbf{x} \right) = \prod_{k=1}^K \prod_{i=1}^{I} \sigma \left( LLR_p(k,i) \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(LLR_p(k,i)\)</span> is the prior knowledge of the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit of the
<span class="math notranslate nohighlight">\(k\text{th}\)</span> user given as an LLR, and <span class="math notranslate nohighlight">\(\sigma\left(\cdot\right)\)</span> is the sigmoid function.
The definition of the LLR has been chosen such that it is equivalent with that of logit. This is
different from many textbooks in communications, where the LLR is
defined as <span class="math notranslate nohighlight">\(LLR(k,i) = \ln\left(\frac{\Pr\left(b_{k,i}=0\lvert \mathbf{y},\mathbf{H}\right)}{\Pr\left(b_{k,i}=1\lvert \mathbf{y},\mathbf{H}\right)}\right)\)</span>.</p>
<p>With the “maxlog” demapping method, the LLR for the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user is approximated like</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    LLR(k,i) \approx&amp;\ln\left(\frac{
        \max_{\mathbf{x}\in\mathcal{C}_{k,i,1}} \left( \exp\left(
            -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
            \right) \Pr\left( \mathbf{x} \right) \right)
        }{
        \max_{\mathbf{x}\in\mathcal{C}_{k,i,0}} \left( \exp\left(
            -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
            \right) \Pr\left( \mathbf{x} \right) \right)
        }\right)\\
        = &amp;\min_{\mathbf{x}\in\mathcal{C}_{k,i,0}} \left( \left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2 - \ln \left(\Pr\left( \mathbf{x} \right) \right) \right) -
            \min_{\mathbf{x}\in\mathcal{C}_{k,i,1}} \left( \left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2 - \ln \left( \Pr\left( \mathbf{x} \right) \right) \right).
    \end{align}\end{split}\]</div>
<p><strong>ML detection of symbols:</strong></p>
<p>Soft-decisions on symbols are called logits (i.e., unnormalized log-probability).</p>
<p>With the “app” demapping method, the logit for the
constellation point <span class="math notranslate nohighlight">\(c \in \mathcal{C}\)</span> of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user  is computed according to</p>
<div class="math notranslate nohighlight">
\[\begin{align}
    \text{logit}(k,c) &amp;= \ln\left(\sum_{\mathbf{x} : x_k = c} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right)\Pr\left( \mathbf{x} \right)\right).
\end{align}\]</div>
<p>With the “maxlog” demapping method, the logit for the constellation point <span class="math notranslate nohighlight">\(c \in \mathcal{C}\)</span>
of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> user  is approximated like</p>
<div class="math notranslate nohighlight">
\[\text{logit}(k,c) \approx \max_{\mathbf{x} : x_k = c} \left(
        -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2 + \ln \left( \Pr\left( \mathbf{x} \right) \right)
        \right).\]</div>
<p>When hard decisions are requested, this layer returns for the <span class="math notranslate nohighlight">\(k\)</span> th stream</p>
<div class="math notranslate nohighlight">
\[\hat{c}_k = \underset{c \in \mathcal{C}}{\text{argmax}} \left( \sum_{\mathbf{x} : x_k = c} \exp\left(
                -\left\lVert\tilde{\mathbf{y}}-\tilde{\mathbf{H}}\mathbf{x}\right\rVert^2
                \right)\Pr\left( \mathbf{x} \right) \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> is the set of constellation points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> (<em>One of</em><em> [</em><em>&quot;bit&quot;</em><em>, </em><em>&quot;symbol&quot;</em><em>]</em><em>, </em><em>str</em>) – The type of output, either LLRs on bits or logits on constellation symbols.</p></li>
<li><p><strong>demapping_method</strong> (<em>One of</em><em> [</em><em>&quot;app&quot;</em><em>, </em><em>&quot;maxlog&quot;</em><em>]</em><em>, </em><em>str</em>) – The demapping method used.</p></li>
<li><p><strong>num_streams</strong> (<em>tf.int</em>) – Number of transmitted streams</p></li>
<li><p><strong>constellation_type</strong> (<em>One of</em><em> [</em><em>&quot;qam&quot;</em><em>, </em><em>&quot;pam&quot;</em><em>, </em><em>&quot;custom&quot;</em><em>]</em><em>, </em><em>str</em>) – For “custom”, an instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a>
must be provided.</p></li>
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – The number of bits per constellation symbol, e.g., 4 for QAM16.
Only required for <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code> in [“qam”, “pam”].</p></li>
<li><p><strong>constellation</strong> (<a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><em>Constellation</em></a>) – An instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a> or <cite>None</cite>.
In the latter case, <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code>
and <code class="docutils literal notranslate"><span class="pre">num_bits_per_symbol</span></code> must be provided.</p></li>
<li><p><strong>hard_out</strong> (<em>bool</em>) – If <cite>True</cite>, the detector computes hard-decided bit values or
constellation point indices instead of soft-values.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>One of</em><em> [</em><em>tf.complex64</em><em>, </em><em>tf.complex128</em><em>] </em><em>tf.DType</em><em> (</em><em>dtype</em><em>)</em>) – The dtype of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Defaults to tf.complex64.
The output dtype is the corresponding real dtype (tf.float32 or tf.float64).</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, h, prior, s)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,num_streams], tf.complex</em>) – 2+D tensor containing the channel matrices.</p></li>
<li><p><strong>prior</strong> (<em>[…,num_streams,num_bits_per_symbol] or […,num_streams,num_points], tf.float</em>) – Prior of the transmitted signals.
If <code class="docutils literal notranslate"><span class="pre">output</span></code> equals “bit”, then LLRs of the transmitted bits are expected.
If <code class="docutils literal notranslate"><span class="pre">output</span></code> equals “symbol”, then logits of the transmitted constellation points are expected.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>One of</strong></p></li>
<li><p><em>[…, num_streams, num_bits_per_symbol], tf.float</em> – LLRs or hard-decisions for every bit of every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“bit”</cite>.</p></li>
<li><p><em>[…, num_streams, num_points], tf.float or […, num_streams], tf.int</em> – Logits or hard-decisions for constellation symbols for every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“symbol”</cite>.
Hard-decisions correspond to the symbol indices.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to use this layer in Graph mode with XLA, i.e., within
a function that is decorated with <code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>,
you must set <code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="mmse-pic">
<h3>MMSE-PIC<a class="headerlink" href="#mmse-pic" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.MMSEPICDetector">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">MMSEPICDetector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demapping_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxlog'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constellation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tf.complex64</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/detection.html#MMSEPICDetector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.MMSEPICDetector" title="Permalink to this definition"></a></dt>
<dd><p>Minimum mean square error (MMSE) with parallel interference cancellation (PIC) detector</p>
<p>This layer implements the MMSE PIC detector, as proposed in <a class="reference internal" href="#cst2011" id="id7"><span>[CST2011]</span></a>.
For <code class="docutils literal notranslate"><span class="pre">num_iter</span></code>&gt;1, this implementation performs MMSE PIC self-iterations.
MMSE PIC self-iterations can be understood as a concatenation of MMSE PIC
detectors from <a class="reference internal" href="#cst2011" id="id8"><span>[CST2011]</span></a>, which forward intrinsic LLRs to the next
self-iteration.</p>
<p>Compared to <a class="reference internal" href="#cst2011" id="id9"><span>[CST2011]</span></a>, this implementation also accepts priors on the
constellation symbols as an alternative to priors on the bits.</p>
<p>This layer assumes the following channel model:</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathcal{C}^S\)</span> is the vector of transmitted symbols which
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times S}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a complex Gaussian noise vector.
It is assumed that <span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\mathbf{n}\mathbf{n}^{\mathsf{H}}\right]=\mathbf{S}\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> has full rank.</p>
<p>The algorithm starts by computing the soft symbols
<span class="math notranslate nohighlight">\(\bar{x}_s=\mathbb{E}\left[ x_s \right]\)</span> and
variances <span class="math notranslate nohighlight">\(v_s=\mathbb{E}\left[ |e_s|^2\right]\)</span> from the priors,
where <span class="math notranslate nohighlight">\(e_s = x_s - \bar{x}_s\)</span>, for all <span class="math notranslate nohighlight">\(s=1,\dots,S\)</span>.</p>
<p>Next, for each stream, the interference caused by all other streams is cancelled
from the observation <span class="math notranslate nohighlight">\(\mathbf{y}\)</span>, leading to</p>
<div class="math notranslate nohighlight">
\[\hat{\mathbf{y}}_s = \mathbf{y} - \sum_{j\neq s} \mathbf{h}_j x_j = \mathbf{h}_s x_s + \tilde{\mathbf{n}}_s,\quad s=1,\dots,S\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{\mathbf{n}}_s=\sum_{j\neq s} \mathbf{h}_j e_j + \mathbf{n}\)</span>.</p>
<p>Then, a linear MMSE filter <span class="math notranslate nohighlight">\(\mathbf{w}_s\)</span> is computed to reduce the resdiual noise
for each observation <span class="math notranslate nohighlight">\(\hat{\mathbf{y}}_s\)</span>, which is given as</p>
<div class="math notranslate nohighlight">
\[\mathbf{w}_s = \mathbf{h}_s^{\mathsf{H}}\left( \mathbf{H} \mathbf{D}_s\mathbf{H}^{\mathsf{H}} +\mathbf{S} \right)^{-1}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{D}_s \in \mathbb{C}^{S\times S}\)</span> is diagonal with entries</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\mathbf{D}_s\right]_{i,i} = \begin{cases}
                                    v_i &amp; i\neq s \\
                                    1 &amp; i=s.
                                  \end{cases}\end{split}\]</div>
<p>The filtered observations</p>
<div class="math notranslate nohighlight">
\[\tilde{z}_s = \mathbf{w}_s^{\mathsf{H}} \hat{\mathbf{y}}_s = \tilde{\mu}_s x_s + \mathbf{w}_s^{\mathsf{H}}\tilde{\mathbf{n}}_s\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{\mu}_s=\mathbf{w}_s^{\mathsf{H}} \mathbf{h}_s\)</span>, are then demapped to either symbol logits or LLRs, assuming that the remaining noise is Gaussian with variance</p>
<div class="math notranslate nohighlight">
\[\nu_s^2 = \mathop{\text{Var}}\left[\tilde{z}_s\right] = \mathbf{w}_s^{\mathsf{H}} \left(\sum_{j\neq s} \mathbf{h}_j \mathbf{h}_j^{\mathsf{H}} v_j +\mathbf{S} \right)\mathbf{w}_s.\]</div>
<p>The resulting soft-symbols can then be used for the next self-iteration of the algorithm.</p>
<p>Note that this algorithm can be substantially simplified as described in <a class="reference internal" href="#cst2011" id="id10"><span>[CST2011]</span></a> to avoid
the computation of different matrix inverses for each stream. This is the version which is
implemented.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output</strong> (<em>One of</em><em> [</em><em>&quot;bit&quot;</em><em>, </em><em>&quot;symbol&quot;</em><em>]</em><em>, </em><em>str</em>) – The type of output, either LLRs on bits or logits on constellation
symbols.</p></li>
<li><p><strong>demapping_method</strong> (<em>One of</em><em> [</em><em>&quot;app&quot;</em><em>, </em><em>&quot;maxlog&quot;</em><em>]</em><em>, </em><em>str</em>) – The demapping method used.
Defaults to “maxlog”.</p></li>
<li><p><strong>num_iter</strong> (<em>int</em>) – Number of MMSE PIC iterations.
Defaults to 1.</p></li>
<li><p><strong>constellation_type</strong> (<em>One of</em><em> [</em><em>&quot;qam&quot;</em><em>, </em><em>&quot;pam&quot;</em><em>, </em><em>&quot;custom&quot;</em><em>]</em><em>, </em><em>str</em>) – For “custom”, an instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a>
must be provided.</p></li>
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – The number of bits per constellation symbol, e.g., 4 for QAM16.
Only required for <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code> in [“qam”, “pam”].</p></li>
<li><p><strong>constellation</strong> (<a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><em>Constellation</em></a>) – An instance of <a class="reference internal" href="mapping.html#sionna.mapping.Constellation" title="sionna.mapping.Constellation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constellation</span></code></a> or <cite>None</cite>.
In the latter case, <code class="docutils literal notranslate"><span class="pre">constellation_type</span></code>
and <code class="docutils literal notranslate"><span class="pre">num_bits_per_symbol</span></code> must be provided.</p></li>
<li><p><strong>hard_out</strong> (<em>bool</em>) – If <cite>True</cite>, the detector computes hard-decided bit values or
constellation point indices instead of soft-values.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>One of</em><em> [</em><em>tf.complex64</em><em>, </em><em>tf.complex128</em><em>] </em><em>tf.DType</em><em> (</em><em>dtype</em><em>)</em>) – The dtype of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Defaults to tf.complex64.
The output dtype is the corresponding real dtype
(tf.float32 or tf.float64).</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, h, prior, s)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals</p></li>
<li><p><strong>h</strong> (<em>[…,M,S], tf.complex</em>) – 2+D tensor containing the channel matrices</p></li>
<li><p><strong>prior</strong> (<em>[…,S,num_bits_per_symbol] or […,S,num_points], tf.float</em>) – Prior of the transmitted signals.
If <code class="docutils literal notranslate"><span class="pre">output</span></code> equals “bit”, then LLRs of the transmitted bits are expected.
If <code class="docutils literal notranslate"><span class="pre">output</span></code> equals “symbol”, then logits of the transmitted constellation points are expected.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>One of</strong></p></li>
<li><p><em>[…,S,num_bits_per_symbol], tf.float</em> – LLRs or hard-decisions for every bit of every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“bit”</cite></p></li>
<li><p><em>[…,S,2**num_bits_per_symbol], tf.float or […,S], tf.int</em> – Logits or hard-decisions for constellation symbols for every stream, if <code class="docutils literal notranslate"><span class="pre">output</span></code> equals <cite>“symbol”</cite></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For numerical stability, we do not recommend to use this function in Graph
mode with XLA, i.e., within a function that is decorated with
<code class="docutils literal notranslate"><span class="pre">&#64;tf.function(jit_compile=True)</span></code>.
However, it is possible to do so by setting
<code class="docutils literal notranslate"><span class="pre">sionna.Config.xla_compat=true</span></code>.
See <a class="reference internal" href="config.html#sionna.Config.xla_compat" title="sionna.Config.xla_compat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xla_compat</span></code></a>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Permalink to this headline"></a></h2>
<div class="section" id="list2llr">
<h3>List2LLR<a class="headerlink" href="#list2llr" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.List2LLR">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">List2LLR</span></span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#List2LLR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.List2LLR" title="Permalink to this definition"></a></dt>
<dd><p>Abstract class defining a callable to compute LLRs from a list of
candidate vectors (or paths) provided by a MIMO detector.</p>
<p>The following channel model is assumed</p>
<div class="math notranslate nohighlight">
\[\bar{\mathbf{y}} = \mathbf{R}\bar{\mathbf{x}} + \bar{\mathbf{n}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{\mathbf{y}}\in\mathbb{C}^S\)</span> are the channel outputs,
<span class="math notranslate nohighlight">\(\mathbf{R}\in\mathbb{C}^{S\times S}\)</span> is an upper-triangular matrix,
<span class="math notranslate nohighlight">\(\bar{\mathbf{x}}\in\mathbb{C}^S\)</span> is the transmitted vector whose entries
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
and <span class="math notranslate nohighlight">\(\bar{\mathbf{n}}\in\mathbb{C}^S\)</span> is white noise
with <span class="math notranslate nohighlight">\(\mathbb{E}\left[\bar{\mathbf{n}}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\bar{\mathbf{n}}\bar{\mathbf{n}}^{\mathsf{H}}\right]=\mathbf{I}\)</span>.</p>
<p>It is assumed that a MIMO detector such as <a class="reference internal" href="#sionna.mimo.KBestDetector" title="sionna.mimo.KBestDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KBestDetector</span></code></a>
produces <span class="math notranslate nohighlight">\(K\)</span> candidate solutions <span class="math notranslate nohighlight">\(\bar{\mathbf{x}}_k\in\mathcal{C}^S\)</span>
and their associated distance metrics <span class="math notranslate nohighlight">\(d_k=\lVert \bar{\mathbf{y}} - \mathbf{R}\bar{\mathbf{x}}_k \rVert^2\)</span>
for <span class="math notranslate nohighlight">\(k=1,\dots,K\)</span>. This layer can also be used with the real-valued representation of the channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(y, r, dists, path_inds, path_syms)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex or tf.float</em>) – Channel outputs of the whitened channel</p></li>
<li><p><strong>r</strong> ([…,num_streams, num_streams], same dtype as <code class="docutils literal notranslate"><span class="pre">y</span></code>) – Upper triangular channel matrix of the whitened channel</p></li>
<li><p><strong>dists</strong> (<em>[…,num_paths], tf.float</em>) – Distance metric for each path (or candidate)</p></li>
<li><p><strong>path_inds</strong> (<em>[…,num_paths,num_streams], tf.int32</em>) – Symbol indices for every stream of every path (or candidate)</p></li>
<li><p><strong>path_syms</strong> ([…,num_path,num_streams], same dtype as <code class="docutils literal notranslate"><span class="pre">y</span></code>) – Constellation symbol for every stream of every path (or candidate)</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><strong>llr</strong> (<em>[…num_streams,num_bits_per_symbol], tf.float</em>) – LLRs for all bits of every stream</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An implementation of this class does not need to make use of all of
the provided inputs which enable various different implementations.</p>
</div>
</dd></dl>

</div>
<div class="section" id="list2llrsimple">
<h3>List2LLRSimple<a class="headerlink" href="#list2llrsimple" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="sionna.mimo.List2LLRSimple">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">List2LLRSimple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_bits_per_symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">llr_clip_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#List2LLRSimple"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.List2LLRSimple" title="Permalink to this definition"></a></dt>
<dd><p>Computes LLRs from a list of candidate vectors (or paths) provided by a MIMO detector.</p>
<p>The following channel model is assumed:</p>
<div class="math notranslate nohighlight">
\[\bar{\mathbf{y}} = \mathbf{R}\bar{\mathbf{x}} + \bar{\mathbf{n}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{\mathbf{y}}\in\mathbb{C}^S\)</span> are the channel outputs,
<span class="math notranslate nohighlight">\(\mathbf{R}\in\mathbb{C}^{S\times S}\)</span> is an upper-triangular matrix,
<span class="math notranslate nohighlight">\(\bar{\mathbf{x}}\in\mathbb{C}^S\)</span> is the transmitted vector whose entries
are uniformly and independently drawn from the constellation <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
and <span class="math notranslate nohighlight">\(\bar{\mathbf{n}}\in\mathbb{C}^S\)</span> is white noise
with <span class="math notranslate nohighlight">\(\mathbb{E}\left[\bar{\mathbf{n}}\right]=\mathbf{0}\)</span> and
<span class="math notranslate nohighlight">\(\mathbb{E}\left[\bar{\mathbf{n}}\bar{\mathbf{n}}^{\mathsf{H}}\right]=\mathbf{I}\)</span>.</p>
<p>It is assumed that a MIMO detector such as <a class="reference internal" href="#sionna.mimo.KBestDetector" title="sionna.mimo.KBestDetector"><code class="xref py py-class docutils literal notranslate"><span class="pre">KBestDetector</span></code></a>
produces <span class="math notranslate nohighlight">\(K\)</span> candidate solutions <span class="math notranslate nohighlight">\(\bar{\mathbf{x}}_k\in\mathcal{C}^S\)</span>
and their associated distance metrics <span class="math notranslate nohighlight">\(d_k=\lVert \bar{\mathbf{y}} - \mathbf{R}\bar{\mathbf{x}}_k \rVert^2\)</span>
for <span class="math notranslate nohighlight">\(k=1,\dots,K\)</span>. This layer can also be used with the real-valued representation of the channel.</p>
<p>The LLR for the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit of the <span class="math notranslate nohighlight">\(k\text{th}\)</span> stream is computed as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    LLR(k,i) &amp;= \log\left(\frac{\Pr(b_{k,i}=1|\bar{\mathbf{y}},\mathbf{R})}{\Pr(b_{k,i}=0|\bar{\mathbf{y}},\mathbf{R})}\right)\\
        &amp;\approx \min_{j \in  \mathcal{C}_{k,i,0}}d_j - \min_{j \in  \mathcal{C}_{k,i,1}}d_j
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,1}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,0}\)</span> are the set of indices
in the list of candidates for which the <span class="math notranslate nohighlight">\(i\text{th}\)</span> bit of the <span class="math notranslate nohighlight">\(k\text{th}\)</span>
stream is equal to 1 and 0, respectively. The LLRs are clipped to <span class="math notranslate nohighlight">\(\pm LLR_\text{clip}\)</span>
which can be configured through the parameter <code class="docutils literal notranslate"><span class="pre">llr_clip_val</span></code>.</p>
<p>If <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,0}\)</span> is empty, <span class="math notranslate nohighlight">\(LLR(k,i)=LLR_\text{clip}\)</span>;
if <span class="math notranslate nohighlight">\(\mathcal{C}_{k,i,1}\)</span> is empty, <span class="math notranslate nohighlight">\(LLR(k,i)=-LLR_\text{clip}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_bits_per_symbol</strong> (<em>int</em>) – Number of bits per constellation symbol</p></li>
<li><p><strong>llr_clip_val</strong> (<em>float</em>) – The absolute values of LLRs are clipped to this value.
Defaults to 20.0. Can also be a trainable variable.</p></li>
</ul>
</dd>
<dt class="field-even">Input</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>(y, r, dists, path_inds, path_syms)</strong> – Tuple:</p></li>
<li><p><strong>y</strong> (<em>[…,M], tf.complex or tf.float</em>) – Channel outputs of the whitened channel</p></li>
<li><p><strong>r</strong> ([…,num_streams, num_streams], same dtype as <code class="docutils literal notranslate"><span class="pre">y</span></code>) – Upper triangular channel matrix of the whitened channel</p></li>
<li><p><strong>dists</strong> (<em>[…,num_paths], tf.float</em>) – Distance metric for each path (or candidate)</p></li>
<li><p><strong>path_inds</strong> (<em>[…,num_paths,num_streams], tf.int32</em>) – Symbol indices for every stream of every path (or candidate)</p></li>
<li><p><strong>path_syms</strong> ([…,num_path,num_streams], same dtype as <code class="docutils literal notranslate"><span class="pre">y</span></code>) – Constellation symbol for every stream of every path (or candidate)</p></li>
</ul>
</dd>
<dt class="field-odd">Output</dt>
<dd class="field-odd"><p><strong>llr</strong> (<em>[…num_streams,num_bits_per_symbol], tf.float</em>) – LLRs for all bits of every stream</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="complex2real-vector">
<h3>complex2real_vector<a class="headerlink" href="#complex2real-vector" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.complex2real_vector">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">complex2real_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#complex2real_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.complex2real_vector" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a complex-valued vector into its real-valued equivalent.</p>
<p>Transforms the last dimension of a complex-valued tensor into
its real-valued equivalent by stacking the real and imaginary
parts on top of each other.</p>
<p>For a vector <span class="math notranslate nohighlight">\(\mathbf{z}\in \mathbb{C}^M\)</span> with real and imaginary
parts <span class="math notranslate nohighlight">\(\mathbf{x}\in \mathbb{R}^M\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{y}\in \mathbb{R}^M\)</span>, respectively, this function returns
the vector <span class="math notranslate nohighlight">\(\left[\mathbf{x}^{\mathsf{T}}, \mathbf{y}^{\mathsf{T}} \right ]^{\mathsf{T}}\in\mathbb{R}^{2M}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><p><em>[…,M], tf.complex</em></p>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><em>[…,2M], tf.complex.real_dtype</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="real2complex-vector">
<h3>real2complex_vector<a class="headerlink" href="#real2complex-vector" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.real2complex_vector">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">real2complex_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#real2complex_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.real2complex_vector" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a real-valued vector into its complex-valued equivalent.</p>
<p>Transforms the last dimension of a real-valued tensor into
its complex-valued equivalent by interpreting the first half
as the real and the second half as the imaginary part.</p>
<p>For a vector <span class="math notranslate nohighlight">\(\mathbf{z}=\left[\mathbf{x}^{\mathsf{T}}, \mathbf{y}^{\mathsf{T}} \right ]^{\mathsf{T}}\in \mathbb{R}^{2M}\)</span>
with <span class="math notranslate nohighlight">\(\mathbf{x}\in \mathbb{R}^M\)</span> and <span class="math notranslate nohighlight">\(\mathbf{y}\in \mathbb{R}^M\)</span>,
this function returns
the vector <span class="math notranslate nohighlight">\(\mathbf{x}+j\mathbf{y}\in\mathbb{C}^M\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><p><em>[…,2M], tf.float</em></p>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><em>[…,M], tf.complex</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="complex2real-matrix">
<h3>complex2real_matrix<a class="headerlink" href="#complex2real-matrix" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.complex2real_matrix">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">complex2real_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#complex2real_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.complex2real_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a complex-valued matrix into its real-valued equivalent.</p>
<p>Transforms the last two dimensions of a complex-valued tensor into
their real-valued matrix equivalent representation.</p>
<p>For a matrix <span class="math notranslate nohighlight">\(\mathbf{Z}\in \mathbb{C}^{M\times K}\)</span> with real and imaginary
parts <span class="math notranslate nohighlight">\(\mathbf{X}\in \mathbb{R}^{M\times K}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{Y}\in \mathbb{R}^{M\times K}\)</span>, respectively, this function returns
the matrix <span class="math notranslate nohighlight">\(\tilde{\mathbf{Z}}\in \mathbb{R}^{2M\times 2K}\)</span>, given as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{\mathbf{Z}} = \begin{pmatrix}
                        \mathbf{X} &amp; -\mathbf{Y}\\
                        \mathbf{Y} &amp; \mathbf{X}
                     \end{pmatrix}.\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><p><em>[…,M,K], tf.complex</em></p>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><em>[…,2M, 2K], tf.complex.real_dtype</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="real2complex-matrix">
<h3>real2complex_matrix<a class="headerlink" href="#real2complex-matrix" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.real2complex_matrix">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">real2complex_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#real2complex_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.real2complex_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a real-valued matrix into its complex-valued equivalent.</p>
<p>Transforms the last two dimensions of a real-valued tensor into
their complex-valued matrix equivalent representation.</p>
<p>For a matrix <span class="math notranslate nohighlight">\(\tilde{\mathbf{Z}}\in \mathbb{R}^{2M\times 2K}\)</span>,
satisfying</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{\mathbf{Z}} = \begin{pmatrix}
                        \mathbf{X} &amp; -\mathbf{Y}\\
                        \mathbf{Y} &amp; \mathbf{X}
                     \end{pmatrix}\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{X}\in \mathbb{R}^{M\times K}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{Y}\in \mathbb{R}^{M\times K}\)</span>, this function returns
the matrix <span class="math notranslate nohighlight">\(\mathbf{Z}=\mathbf{X}+j\mathbf{Y}\in\mathbb{C}^{M\times K}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><p><em>[…,2M,2K], tf.float</em></p>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><em>[…,M, 2], tf.complex</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="complex2real-covariance">
<h3>complex2real_covariance<a class="headerlink" href="#complex2real-covariance" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.complex2real_covariance">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">complex2real_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#complex2real_covariance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.complex2real_covariance" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a complex-valued covariance matrix to its real-valued equivalent.</p>
<p>Assume a proper complex random variable <span class="math notranslate nohighlight">\(\mathbf{z}\in\mathbb{C}^M\)</span> <a class="reference internal" href="#properrv" id="id11"><span>[ProperRV]</span></a>
with covariance matrix <span class="math notranslate nohighlight">\(\mathbf{R}= \in\mathbb{C}^{M\times M}\)</span>
and real and imaginary parts <span class="math notranslate nohighlight">\(\mathbf{x}\in \mathbb{R}^M\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{y}\in \mathbb{R}^M\)</span>, respectively.
This function transforms the given <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> into the covariance matrix of the real-valued equivalent
vector <span class="math notranslate nohighlight">\(\tilde{\mathbf{z}}=\left[\mathbf{x}^{\mathsf{T}}, \mathbf{y}^{\mathsf{T}} \right ]^{\mathsf{T}}\in\mathbb{R}^{2M}\)</span>, which
is computed as <a class="reference internal" href="#covproperrv" id="id12"><span>[CovProperRV]</span></a></p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{E}\left[\tilde{\mathbf{z}}\tilde{\mathbf{z}}^{\mathsf{H}} \right] =
\begin{pmatrix}
    \frac12\Re\{\mathbf{R}\} &amp; -\frac12\Im\{\mathbf{R}\}\\
    \frac12\Im\{\mathbf{R}\} &amp; \frac12\Re\{\mathbf{R}\}
\end{pmatrix}.\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><p><em>[…,M,M], tf.complex</em></p>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><em>[…,2M, 2M], tf.complex.real_dtype</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="real2complex-covariance">
<h3>real2complex_covariance<a class="headerlink" href="#real2complex-covariance" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.real2complex_covariance">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">real2complex_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#real2complex_covariance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.real2complex_covariance" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a real-valued covariance matrix to its complex-valued equivalent.</p>
<p>Assume a proper complex random variable <span class="math notranslate nohighlight">\(\mathbf{z}\in\mathbb{C}^M\)</span> <a class="reference internal" href="#properrv" id="id13"><span>[ProperRV]</span></a>
with covariance matrix <span class="math notranslate nohighlight">\(\mathbf{R}= \in\mathbb{C}^{M\times M}\)</span>
and real and imaginary parts <span class="math notranslate nohighlight">\(\mathbf{x}\in \mathbb{R}^M\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{y}\in \mathbb{R}^M\)</span>, respectively.
This function transforms the given covariance matrix of the real-valued equivalent
vector <span class="math notranslate nohighlight">\(\tilde{\mathbf{z}}=\left[\mathbf{x}^{\mathsf{T}}, \mathbf{y}^{\mathsf{T}} \right ]^{\mathsf{T}}\in\mathbb{R}^{2M}\)</span>, which
is given as <a class="reference internal" href="#covproperrv" id="id14"><span>[CovProperRV]</span></a></p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{E}\left[\tilde{\mathbf{z}}\tilde{\mathbf{z}}^{\mathsf{H}} \right] =
\begin{pmatrix}
    \frac12\Re\{\mathbf{R}\} &amp; -\frac12\Im\{\mathbf{R}\}\\
    \frac12\Im\{\mathbf{R}\} &amp; \frac12\Re\{\mathbf{R}\}
\end{pmatrix},\end{split}\]</div>
<p>into is complex-valued equivalent <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><p><em>[…,2M,2M], tf.float</em></p>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><p><em>[…,M, M], tf.complex</em></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="complex2real-channel">
<h3>complex2real_channel<a class="headerlink" href="#complex2real-channel" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.complex2real_channel">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">complex2real_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#complex2real_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.complex2real_channel" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a complex-valued MIMO channel into its real-valued equivalent.</p>
<p>Assume the canonical MIMO channel model</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K\)</span> is the vector of transmitted symbols,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a noise vector with covariance
matrix <span class="math notranslate nohighlight">\(\mathbf{S}\in\mathbb{C}^{M\times M}\)</span>.</p>
<p>This function returns the real-valued equivalent representations of
<span class="math notranslate nohighlight">\(\mathbf{y}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{H}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>,
which are used by a wide variety of MIMO detection algorithms (Section VII) <a class="reference internal" href="#yh2015" id="id15"><span>[YH2015]</span></a>.
These are obtained by applying <a class="reference internal" href="#sionna.mimo.complex2real_vector" title="sionna.mimo.complex2real_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complex2real_vector()</span></code></a> to <span class="math notranslate nohighlight">\(\mathbf{y}\)</span>,
<a class="reference internal" href="#sionna.mimo.complex2real_matrix" title="sionna.mimo.complex2real_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complex2real_matrix()</span></code></a> to <span class="math notranslate nohighlight">\(\mathbf{H}\)</span>,
and <a class="reference internal" href="#sionna.mimo.complex2real_covariance" title="sionna.mimo.complex2real_covariance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complex2real_covariance()</span></code></a> to <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>[…,M], tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,K], tf.complex</em>) – 2+D tensor containing the channel matrices.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><em>[…,2M], tf.complex.real_dtype</em> – 1+D tensor containing the real-valued equivalent received signals.</p></li>
<li><p><em>[…,2M,2K], tf.complex.real_dtype</em> – 2+D tensor containing the real-valued equivalent channel matrices.</p></li>
<li><p><em>[…,2M,2M], tf.complex.real_dtype</em> – 2+D tensor containing the real-valued equivalent noise covariance matrices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="real2complex-channel">
<h3>real2complex_channel<a class="headerlink" href="#real2complex-channel" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.real2complex_channel">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">real2complex_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#real2complex_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.real2complex_channel" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a real-valued MIMO channel into its complex-valued equivalent.</p>
<p>Assume the canonical MIMO channel model</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K\)</span> is the vector of transmitted symbols,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M\)</span> is a noise vector with covariance
matrix <span class="math notranslate nohighlight">\(\mathbf{S}\in\mathbb{C}^{M\times M}\)</span>.</p>
<p>This function transforms the real-valued equivalent representations of
<span class="math notranslate nohighlight">\(\mathbf{y}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{H}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, as, e.g.,
obtained with the function <a class="reference internal" href="#sionna.mimo.complex2real_channel" title="sionna.mimo.complex2real_channel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">complex2real_channel()</span></code></a>,
back to their complex-valued equivalents (Section VII) <a class="reference internal" href="#yh2015" id="id16"><span>[YH2015]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>[…,2M], tf.float</em>) – 1+D tensor containing the real-valued received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,2M,2K], tf.float</em>) – 2+D tensor containing the real-valued channel matrices.</p></li>
<li><p><strong>s</strong> (<em>[…,2M,2M], tf.float</em>) – 2+D tensor containing the real-valued noise covariance matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><em>[…,M], tf.complex</em> – 1+D tensor containing the complex-valued equivalent received signals.</p></li>
<li><p><em>[…,M,K], tf.complex</em> – 2+D tensor containing the complex-valued equivalent channel matrices.</p></li>
<li><p><em>[…,M,M], tf.complex</em> – 2+D tensor containing the complex-valued equivalent noise covariance matrices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="whiten-channel">
<h3>whiten_channel<a class="headerlink" href="#whiten-channel" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sionna.mimo.whiten_channel">
<span class="sig-prename descclassname"><span class="pre">sionna.mimo.</span></span><span class="sig-name descname"><span class="pre">whiten_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sionna/mimo/utils.html#whiten_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sionna.mimo.whiten_channel" title="Permalink to this definition"></a></dt>
<dd><p>Whitens a canonical MIMO channel.</p>
<p>Assume the canonical MIMO channel model</p>
<div class="math notranslate nohighlight">
\[\mathbf{y} = \mathbf{H}\mathbf{x} + \mathbf{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{y}\in\mathbb{C}^M(\mathbb{R}^M)\)</span> is the received signal vector,
<span class="math notranslate nohighlight">\(\mathbf{x}\in\mathbb{C}^K(\mathbb{R}^K)\)</span> is the vector of transmitted symbols,
<span class="math notranslate nohighlight">\(\mathbf{H}\in\mathbb{C}^{M\times K}(\mathbb{R}^{M\times K})\)</span> is the known channel matrix,
and <span class="math notranslate nohighlight">\(\mathbf{n}\in\mathbb{C}^M(\mathbb{R}^M)\)</span> is a noise vector with covariance
matrix <span class="math notranslate nohighlight">\(\mathbf{S}\in\mathbb{C}^{M\times M}(\mathbb{R}^{M\times M})\)</span>.</p>
<p>This function whitens this channel by multiplying <span class="math notranslate nohighlight">\(\mathbf{y}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{H}\)</span> from the left by <span class="math notranslate nohighlight">\(\mathbf{S}^{-\frac{1}{2}}\)</span>.
Optionally, the whitened noise covariance matrix <span class="math notranslate nohighlight">\(\mathbf{I}_M\)</span>
can be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Input</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>[…,M], tf.float or tf.complex</em>) – 1+D tensor containing the received signals.</p></li>
<li><p><strong>h</strong> (<em>[…,M,K], tf.float or tf.complex</em>) – 2+D tensor containing the  channel matrices.</p></li>
<li><p><strong>s</strong> (<em>[…,M,M], tf.float or complex</em>) – 2+D tensor containing the noise covariance matrices.</p></li>
<li><p><strong>return_s</strong> (<em>bool</em>) – If <cite>True</cite>, the whitened covariance matrix is returned.
Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Output</dt>
<dd class="field-even"><ul class="simple">
<li><p><em>[…,M], tf.float or tf.complex</em> – 1+D tensor containing the whitened received signals.</p></li>
<li><p><em>[…,M,K], tf.float or tf.complex</em> – 2+D tensor containing the whitened channel matrices.</p></li>
<li><p><em>[…,M,M], tf.float or tf.complex</em> – 2+D tensor containing the whitened noise covariance matrices.
Only returned if <code class="docutils literal notranslate"><span class="pre">return_s</span></code> is <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl>
<dt>References:</dt><dd><dl class="citation">
<dt class="label" id="properrv"><span class="brackets">ProperRV</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Complex_random_variable#Proper_complex_random_variables">Proper complex random variables</a>,
Wikipedia, accessed 11 September, 2022.</p>
</dd>
<dt class="label" id="covproperrv"><span class="brackets">CovProperRV</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id14">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Complex_random_vector#Covariance_matrices_of_real_and_imaginary_parts">Covariance matrices of real and imaginary parts</a>,
Wikipedia, accessed 11 September, 2022.</p>
</dd>
<dt class="label" id="yh2015"><span class="brackets">YH2015</span><span class="fn-backref">(<a href="#id15">1</a>,<a href="#id16">2</a>)</span></dt>
<dd><p>S. Yang and L. Hanzo, <a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/7244171">“Fifty Years of MIMO Detection: The Road to Large-Scale MIMOs”</a>,
IEEE Communications Surveys &amp; Tutorials, vol. 17, no. 4, pp. 1941-1988, 2015.</p>
</dd>
<dt class="label" id="ft2015"><span class="brackets"><a class="fn-backref" href="#id6">FT2015</a></span></dt>
<dd><p>W. Fu and J. S. Thompson, <a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/7454351">“Performance analysis of K-best detection with adaptive modulation”</a>, IEEE Int. Symp. Wirel. Commun. Sys. (ISWCS), 2015.</p>
</dd>
<dt class="label" id="ep2014"><span class="brackets"><a class="fn-backref" href="#id5">EP2014</a></span></dt>
<dd><p>J. Céspedes, P. M. Olmos, M. Sánchez-Fernández, and F. Perez-Cruz,
<a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/6841617">“Expectation Propagation Detection for High-Order High-Dimensional MIMO Systems”</a>,
IEEE Trans. Commun., vol. 62, no. 8, pp. 2840-2849, Aug. 2014.</p>
</dd>
<dt class="label" id="cst2011"><span class="brackets">CST2011</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id8">2</a>,<a href="#id9">3</a>,<a href="#id10">4</a>)</span></dt>
<dd><p>C. Studer, S. Fateh, and D. Seethaler,
<a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/5779722">“ASIC Implementation of Soft-Input Soft-Output MIMO Detection Using MMSE Parallel Interference Cancellation”</a>,
IEEE Journal of Solid-State Circuits, vol. 46, no. 7, pp. 1754–1765, July 2011.</p>
</dd>
</dl>
</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ofdm.html" class="btn btn-neutral float-left" title="Orthogonal Frequency-Division Multiplexing (OFDM)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="nr.html" class="btn btn-neutral float-right" title="5G NR" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2024 NVIDIA CORPORATION.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>