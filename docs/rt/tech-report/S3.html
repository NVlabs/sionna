<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<title>3 Path Solver ‣ Sionna RT: Technical Report</title>
<!--Generated on Wed Apr 30 18:10:24 2025 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<link href="LaTeXML.css" rel="stylesheet" type="text/css"/>
<link href="ltx-article.css" rel="stylesheet" type="text/css"/>
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<link href="./" rel="up" title="Sionna RT: Technical Report"/>
<link href="./" rel="start" title="Sionna RT: Technical Report"/>
</head>
<body><div class="nav-panel"><div class="nav-panel-header"><h1 class="nav-panel-header-title">NVIDIA Sionna RT</h1><p class="nav-panel-header-subtitle">Technical Report</p></div><div class="nav-panel-content"><nav class="ltx_TOC"><h2 class="nav-panel-toc-title">Contents</h2><ul class="ltx_toclist"><li class="ltx_tocentry"><a class="ltx_tocentry" href="S1.html">Introduction</a></li><li class="ltx_tocentry"><a class="ltx_tocentry" href="S2.html">Essential Concepts and Terminology</a><ul class="ltx_toclist ltx_toclist_subsections"><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S2.html#SS1">Scene Objects and Meshes</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S2.html#SS2">Rays and Paths</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S2.html#SS3">Interactions with Scene Objects</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S2.html#SS4">Ray Tubes</a></li></ul></li><li class="ltx_tocentry"><a class="ltx_tocentry" href="S3.html">Path Solver</a><ul class="ltx_toclist ltx_toclist_subsections"><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S3.html#SS1">Generating Candidates by Shooting and Bouncing of Rays (SBR)</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S3.html#SS2">Image Method-based Candidate Processing</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S3.html#SS3">Channel Coefficients, Delays, and Doppler Shifts Computation</a></li></ul></li><li class="ltx_tocentry"><a class="ltx_tocentry" href="S4.html">Radio Map Solver</a><ul class="ltx_toclist ltx_toclist_subsections"><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S4.html#SS1">Definition of a Radio Map</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="S4.html#SS2">SBR-based Radio Map Solver</a></li></ul></li><li class="ltx_tocentry"><a class="ltx_tocentry" href="A1.html">Appendix: Primer on Electromagnetism</a><ul class="ltx_toclist ltx_toclist_subsections"><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS1">Coordinate System, Rotations, and Vector Fields</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS2">Planar Time-Harmonic Waves</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS3">Far Field of a Transmitting Antenna</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS4">Modeling of a Receiving Antenna</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS5">General Propagation Path</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS6">Frequency and Impulse Response</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS7">Specular Reflection and Refraction</a></li><li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_tocentry ltx_tocentry_subsection" href="A1.html#SS8">Diffuse Reflection</a></li></ul></li><li class="ltx_tocentry"><a class="ltx_tocentry" href="bib.html">References</a></li></ul></nav></div></div>
<div class="ltx_page_main">
<header class="ltx_page_header">
<div class="ltx_align_center">
<a class="ltx_ref" href="./" rel="up" title=""><span class="ltx_text ltx_ref_title">Sionna RT: Technical Report</span></a>
</div></header>
<div class="ltx_page_content">
<section class="ltx_section ltx_authors_1line" lang="en">
<h1 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3 </span>Path Solver</h1>
<figure class="ltx_figure" id="F7"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="290" id="F7.g1" src="x8.png" width="581"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 7</span>: </span><span class="ltx_text" style="font-size:90%;">The path solver constructs propagation paths that connect a source and a target in a scene.</span></figcaption>
</figure>
<div class="ltx_para" id="p1">
<p class="ltx_p">A path solver aims to determine a set of paths that connect two endpoints in a scene, as illustrated in Figure <a class="ltx_ref" href="#F7" title="Figure 7 ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">7</span></a>.
From this set of paths, a time- or frequency-domain <a href="#glo.acronym.CIR"><span class="ltx_glossaryref" href="#glo.acronym.CIR" title="channel impulse response">CIR</span></a> can be computed.
The path solver leverages <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> to efficiently compute paths in a scene.
<a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> operates as follows:
First, rays<span class="ltx_note ltx_role_footnote" id="footnote2"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup>
<span class="ltx_tag ltx_tag_note">2</span>
            
            
            
          The processing of the rays is parallelized for accelerated computation.</span></span></span> are traced from the source into directions specified by a lattice on the unit sphere (see Section <a class="ltx_ref" href="#SS1.SSS1" title="3.1.1 Sampling Initial Ray Directions ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.1</span></a>).
Then, an <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop iteratively tests the intersection of the rays with the scene geometry.
At every intersection, an interaction type is selected from specular reflection, diffuse reflection, and refraction, and a new ray is spawned according to the selected interaction type.
The method for choosing interaction types is detailed in Section <a class="ltx_ref" href="#SS1.SSS2" title="3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.2</span></a>.
The loop terminates when no more rays remain <em class="ltx_emph ltx_font_italic">active</em>, meaning they have either bounced out of the scene, reached a predefined maximum number of bounces, or satisfied another termination criterion.
Notably, at each interaction of a ray with a surface in the scene, only one scattered ray is spawned, as spawning multiple rays would result in an exponential increase in the number of rays, quickly overwhelming the available computational resources.</p>
</div>
<div class="ltx_para" id="p2">
<p class="ltx_p">When a diffuse reflection occurs during the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop, the solver checks whether there is a <a href="#glo.acronym.LoS"><span class="ltx_glossaryref" href="#glo.acronym.LoS" title="line-of-sight">line-of-sight (LoS)</span></a> to the target, meaning that the ray segment from the interaction point to the target point is not occluded. If such a connection exists, the path is deemed valid and is returned by the solver. This process is known as <em class="ltx_emph ltx_font_italic">next-event estimation</em>. Subsequently, a new ray is spawned in a random direction within the hemisphere defined by the surface normal of the primitive involved. This new ray may lead to the discovery of additional paths.
Next-event estimation is only possible for diffuse reflections that scatter energy into all directions.
For specular reflection and refraction, only a single ray is spawned in the only possible direction.
Consequently, the probability of finding paths connecting the source to the target that end with a specular reflection or refraction by <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> is effectively zero, as depicted in Figure <a class="ltx_ref" href="#F8" title="Figure 8 ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">8</span></a>.
This is because hitting a specific point (the target) with a specular reflection or refraction requires perfect alignment of the incident ray, which has zero probability in continuous space.
Therefore, paths ending with a specular suffix cannot be determined solely by <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>.
Especially, specular chains cannot be computed by <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>.
Since specular chains typically carry a significant amount of the transported energy, <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> alone is insufficient for computing <a href="#glo.acronym.CIR"><span class="ltx_glossaryref" href="#glo.acronym.CIR" title="channel impulse response">CIRs</span></a>.</p>
</div>
<figure class="ltx_figure" id="F8"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="164" id="F8.g1" src="x9.png" width="457"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 8</span>: </span><span class="ltx_text" style="font-size:90%;">When a diffuse reflection occurs, next event estimation tests whether the <a href="#glo.acronym.LoS"><span class="ltx_glossaryref" href="#glo.acronym.LoS" title="line-of-sight">LoS</span></a> between the intersection point and the target is occluded (represented by the dotted line). This process is not applicable for specular reflection (represented by the dashed line) and refraction, as only one single direction for the scattered ray is valid.</span></figcaption>
</figure>
<div class="ltx_para" id="p3">
<p class="ltx_p">To compute paths ending with a specular suffix, including specular chains, the path solver uses an <em class="ltx_emph ltx_font_italic">image method</em>-based algorithm.
However, a brute-force implementation of the image method would test all possible combinations of primitives that constitute the scene and hence is prohibitive even for moderately large scenes.
Therefore, the path solver uses <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> as an heuristic to find <em class="ltx_emph ltx_font_italic">path candidates</em>.
A path candidate consists of a sequence of primitives and interaction types ending with a specular reflection or refraction. As the path vertices determined during the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> do not form a path that connects to the target, the image method is used to adjust the vertex locations to establish the connection.
Intuitively, <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> pre-selects path candidates in the vicinity of the transmitter and receiver for the image method to compute corresponding valid paths to be returned by the solver.
These steps of the Sionna RT path solver are depicted in Figure <a class="ltx_ref" href="#F9" title="Figure 9 ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">9</span></a>.
Notably, only path candidates ending with a specular suffix (including specular chains) require further processing by the image method algorithm.
Finally, for each valid path identified, the path solver computes the corresponding channel coefficients and propagation delays that characterize the <a href="#glo.acronym.EM"><span class="ltx_glossaryref" href="#glo.acronym.EM" title="electromagnetic">EM</span></a> wave propagation along that path.</p>
</div>
<div class="ltx_para" id="p4">
<p class="ltx_p">Alternative methods for identifying paths that include specular chains or specular suffixes may involve detection spheres centered at the targets to capture paths ending with a specular suffix, and/or extending the direction of specular reflection (or refraction) to a lobe around the specular (or refracted) direction. Such methods only approximate the path vertex locations and the directions of the scattered rays, yielding inaccurate path coefficients and consequently resulting in incorrect <a href="#glo.acronym.CIR"><span class="ltx_glossaryref" href="#glo.acronym.CIR" title="channel impulse response">CIRs</span></a>.</p>
</div>
<figure class="ltx_figure" id="F9"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="309" id="F9.g1" src="x10.png" width="581"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 9</span>: </span><span class="ltx_text" style="font-size:90%;">Main steps of the Sionna RT path solver.</span></figcaption>
</figure>
<div class="ltx_para" id="p5">
<p class="ltx_p">The remainder of this section follows the architecture of the path solver shown in Figure <a class="ltx_ref" href="#F9" title="Figure 9 ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">9</span></a>.
First, Section <a class="ltx_ref" href="#SS1" title="3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1</span></a> presents the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>-based candidate generator.
Section <a class="ltx_ref" href="#SS2" title="3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.2</span></a> then describes the image method-based algorithm that processes candidates to find valid paths with specular suffixes.
Finally, Section <a class="ltx_ref" href="#SS3" title="3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.3</span></a> details how the solver computes the complex-valued channel coefficients and propagation delays, which characterize the radio channel.</p>
</div>
<section class="ltx_subsection" id="SS1">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.1 </span>Generating Candidates by Shooting and Bouncing of Rays (SBR)</h2>
<figure class="ltx_figure" id="F10"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="548" id="F10.g1" src="x11.png" width="623"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 10</span>: </span><span class="ltx_text" style="font-size:90%;">Algorithm for one sample as implemented in the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>-based candidate generator. In practice, many samples are processed in parallel.</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.p1">
<p class="ltx_p">The candidate generator utilizes the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>-based method as illustrated in Figure <a class="ltx_ref" href="#F10" title="Figure 10 ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a>.
We first provide an overview of the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> procedure, followed by a detailed explanations.
We consider a scene with a single source located at <math alttext="\mathbf{s}\in\mathbb{R}^{3}" class="ltx_Math" display="inline" id="SS1.p1.m1"><mrow><mi>𝐬</mi><mo>∈</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math> and <math alttext="N_{T}" class="ltx_Math" display="inline" id="SS1.p1.m2"><msub><mi>N</mi><mi>T</mi></msub></math> targets at <math alttext="\mathbf{t}_{k}\in\mathbb{R}^{3}" class="ltx_Math" display="inline" id="SS1.p1.m3"><mrow><msub><mi>𝐭</mi><mi>k</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math>, where <math alttext="k=1,\dots,N_{T}" class="ltx_Math" display="inline" id="SS1.p1.m4"><mrow><mi>k</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>N</mi><mi>T</mi></msub></mrow></mrow></math>.
Although the path solver built into Sionna RT can handle multiple sources, we focus on a single source for the sake of clarity. The process is identical for all sources.
The paths traced by the candidate generator during the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> procedure are referred to as <em class="ltx_emph ltx_font_italic">samples</em> in this section to avoid confusion with the valid paths returned to the user and the candidate paths forwarded to the image method-based algorithm.
A sample therefore consists of a sequence of rays connected end-to-end, traced by the candidate generator.
As we will see, a single sample can result in multiple valid or candidate paths, as illustrated in Figure <a class="ltx_ref" href="#F11" title="Figure 11 ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">11</span></a>.</p>
</div>
<figure class="ltx_figure" id="F11"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="488" id="F11.g1" src="x12.png" width="623"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 11</span>: </span><a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" style="font-size:90%;" title="shooting and bouncing of rays">SBR</span></a><span class="ltx_text" style="font-size:90%;"> procedure for a single sample <math alttext="n" class="ltx_Math" display="inline" id="F11.m2"><mi>n</mi></math> at depths 1, 2, and 3. At each interaction (i.e. iteration of the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop), the sample may result in a candidate or valid path, and a new ray is spawned from the current interaction point to prolong the sample path. Shown in 2D for clarity.</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.p2">
<p class="ltx_p">The <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> procedure begins by spawning a user-specified number of rays, denoted by <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS1.p2.m1"><msub><mi>N</mi><mi>S</mi></msub></math>, from the source <math alttext="\mathbf{s}" class="ltx_Math" display="inline" id="SS1.p2.m2"><mi>𝐬</mi></math> in directions <math alttext="\widehat{\mathbf{k}}_{n}^{(0)}" class="ltx_Math" display="inline" id="SS1.p2.m3"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> on a Fibonacci lattice, where <math alttext="n=1,\dots,N_{S}" class="ltx_Math" display="inline" id="SS1.p2.m4"><mrow><mi>n</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>N</mi><mi>S</mi></msub></mrow></mrow></math>.
Each ray starts a sample that is traced by the candidate generator.
Details on the implemented Fibonacci lattice can be found in Section <a class="ltx_ref" href="#SS1.SSS1" title="3.1.1 Sampling Initial Ray Directions ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.1</span></a>.
The <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop then iterates until either all samples bounce out of the scene or reach a user-specified maximum number of bounces, denoted as the <em class="ltx_emph ltx_font_italic">maximum depth</em> <math alttext="L" class="ltx_Math" display="inline" id="SS1.p2.m5"><mi>L</mi></math>.
We denote the depth of the samples by <math alttext="\ell=0,\dots,L" class="ltx_Math" display="inline" id="SS1.p2.m6"><mrow><mi mathvariant="normal">ℓ</mi><mo>=</mo><mrow><mn>0</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mi>L</mi></mrow></mrow></math>.
The first step of the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop involves testing the intersection of the samples with the scene geometry.
If a sample does not intersect any object, it has bounced out of the scene, and is deactivated.
When a sample <math alttext="n" class="ltx_Math" display="inline" id="SS1.p2.m7"><mi>n</mi></math> with depth <math alttext="\ell" class="ltx_Math" display="inline" id="SS1.p2.m8"><mi mathvariant="normal">ℓ</mi></math> intersects the scene, we denote by <math alttext="\mathbf{v}_{n}^{(\ell)}\in\mathbb{R}^{3}" class="ltx_Math" display="inline" id="SS1.p2.m9"><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math> the intersection point, by <math alttext="\widehat{\mathbf{n}}_{n}^{(\ell)}\in\mathbb{R}^{3}\leavevmode\nobreak\ \left(%
\left\lVert\widehat{\mathbf{n}}_{n}^{(\ell)}\right\rVert_{2}=1\right)" class="ltx_Math" display="inline" id="SS1.p2.m10"><mrow><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><mrow><msup><mi>ℝ</mi><mn>3</mn></msup><mo>⁢</mo><mrow><mo>(</mo><mrow><msub><mrow><mo fence="true" lspace="0em" rspace="0em">∥</mo><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo fence="true" lspace="0em" rspace="0.1389em" stretchy="true">∥</mo></mrow><mn>2</mn></msub><mo lspace="0.1389em">=</mo><mn>1</mn></mrow><mo>)</mo></mrow></mrow></mrow></math> the surface normal at the intersection point oriented towards the half-space containing the incident field, by <math alttext="o_{n}^{(\ell)}\in\mathbb{N}_{0}" class="ltx_Math" display="inline" id="SS1.p2.m11"><mrow><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><msub><mi>ℕ</mi><mn>0</mn></msub></mrow></math> the index of the intersected object, and by <math alttext="m_{n}^{(\ell)}\in\mathbb{N}_{0}" class="ltx_Math" display="inline" id="SS1.p2.m12"><mrow><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><msub><mi>ℕ</mi><mn>0</mn></msub></mrow></math> the index of the specific intersected primitive within that object.
An interaction type, denoted by <math alttext="\chi_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.p2.m13"><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>, is then sampled among specular reflection, diffuse reflection, and refraction, which determines how the sample will continue to propagate.
Details on the sampling of the interaction type are provided in Section <a class="ltx_ref" href="#SS1.SSS2" title="3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.2</span></a>.
The rest of the loop depends on the sampled interaction type.</p>
</div>
<section class="ltx_paragraph" id="SS1.SSS0.Px1">
<h4 class="ltx_title ltx_title_paragraph">Diffuse Reflection</h4>
<div class="ltx_para" id="SS1.SSS0.Px1.p1">
<p class="ltx_p">As previously indicated, diffuse reflection is assumed to scatter energy in all directions of the half-space containing the incident field, which enables next event estimation.
Therefore, if a diffuse reflection is sampled (i.e. <math alttext="\chi_{n}^{(\ell)}={\cal S}" class="ltx_Math" display="inline" id="SS1.SSS0.Px1.p1.m1"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒮</mi></mrow></math>), the <a href="#glo.acronym.LoS"><span class="ltx_glossaryref" href="#glo.acronym.LoS" title="line-of-sight">LoS</span></a> between the intersection point and each target <math alttext="\mathbf{t}_{1},\cdots,\mathbf{t}_{N_{T}}" class="ltx_Math" display="inline" id="SS1.SSS0.Px1.p1.m2"><mrow><msub><mi>𝐭</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><msub><mi>𝐭</mi><msub><mi>N</mi><mi>T</mi></msub></msub></mrow></math> is tested.
For each target <math alttext="\mathbf{t}_{k}" class="ltx_Math" display="inline" id="SS1.SSS0.Px1.p1.m3"><msub><mi>𝐭</mi><mi>k</mi></msub></math> with an unobstructed <a href="#glo.acronym.LoS"><span class="ltx_glossaryref" href="#glo.acronym.LoS" title="line-of-sight">LoS</span></a> to the intersection point, a path connecting the source to the target</p>
<table class="ltx_equation ltx_eqn_table" id="E11">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="p_{n}^{(\ell)}=\left(\mathbf{s},\left(\mathbf{v}_{n}^{(1)},o_{n}^{(1)},m_{n}^{%
(1)},\chi_{n}^{(1)}\right),\cdots,\left(\mathbf{v}_{n}^{(\ell)},o_{n}^{(\ell)}%
,m_{n}^{(\ell)},\chi_{n}^{(\ell)}\right),\mathbf{t}_{k}\right)" class="ltx_Math" display="block" id="E11.m1"><mrow><msubsup><mi>p</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mi>𝐬</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><msub><mi>𝐭</mi><mi>k</mi></msub><mo>)</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(11)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">is recorded as a valid path to be returned to the user.
Note that the path here is enriched with the intersected primitives and the interaction types.
Finally, a new ray is spawned to continue the sample path, with its direction selected uniformly at random from the hemisphere defined by <math alttext="\widehat{\mathbf{n}}_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS0.Px1.p1.m4"><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>, i.e. <math alttext="\widehat{\mathbf{k}}_{n}^{(\ell+1)}\sim{\cal U}_{2\pi}(\widehat{\mathbf{n}}_{n%
}^{(\ell)})" class="ltx_Math" display="inline" id="SS1.SSS0.Px1.p1.m5"><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>∼</mo><mrow><msub><mi class="ltx_font_mathcaligraphic">𝒰</mi><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, where <math alttext="{\cal U}_{2\pi}(\widehat{\mathbf{n}}_{n}^{(\ell)})" class="ltx_Math" display="inline" id="SS1.SSS0.Px1.p1.m6"><mrow><msub><mi class="ltx_font_mathcaligraphic">𝒰</mi><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">)</mo></mrow></mrow></math> represents the uniform distribution on the hemisphere.</p>
</div>
</section>
<section class="ltx_paragraph" id="SS1.SSS0.Px2">
<h4 class="ltx_title ltx_title_paragraph">Specular Reflection and Refraction</h4>
<div class="ltx_para" id="SS1.SSS0.Px2.p1">
<p class="ltx_p">When a specular reflection or refraction is sampled (i.e. <math alttext="\chi_{n}^{(\ell)}={\cal R}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m1"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi></mrow></math> or <math alttext="\chi_{n}^{(\ell)}={\cal T}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m2"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow></math>), the path (<a class="ltx_ref" href="#E11" title="In Diffuse Reflection ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">11</span></a>) is a valid path for target <math alttext="\mathbf{t}_{k}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m3"><msub><mi>𝐭</mi><mi>k</mi></msub></math>, where <math alttext="k\in\left\{1,\dots,N_{T}\right\}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m4"><mrow><mi>k</mi><mo>∈</mo><mrow><mo>{</mo><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>N</mi><mi>T</mi></msub><mo>}</mo></mrow></mrow></math>, only if</p>
<table class="ltx_equation ltx_eqn_table" id="E12">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\frac{\mathbf{t}_{k}-\mathbf{v}_{n}^{(\ell)}}{\left\lVert\mathbf{t}_{k}-%
\mathbf{v}_{n}^{(\ell)}\right\rVert_{2}}=\widehat{\mathbf{k}}_{n}^{(\ell+1)}," class="ltx_Math" display="block" id="E12.m1"><mrow><mrow><mfrac><mrow><msub><mi>𝐭</mi><mi>k</mi></msub><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><msub><mrow><mo fence="true" rspace="0em">∥</mo><mrow><msub><mi>𝐭</mi><mi>k</mi></msub><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub></mfrac><mo>=</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(12)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where</p>
<table class="ltx_equation ltx_eqn_table" id="E13">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\widehat{\mathbf{k}}_{n}^{(\ell+1)}=\begin{cases}\widehat{\mathbf{k}}_{n}^{(%
\ell)}-2\left(\left(\widehat{\mathbf{k}}_{n}^{(\ell)}\right)^{\mathsf{T}}%
\widehat{\mathbf{n}}_{n}^{(\ell)}\right)\widehat{\mathbf{n}}_{n}^{(\ell)}&amp;%
\text{if }\chi_{n}^{(\ell)}={\cal R}\\
\widehat{\mathbf{k}}_{n}^{(\ell)}&amp;\text{if }\chi_{n}^{(\ell)}={\cal T}\end{cases}" class="ltx_Math" display="block" id="E13.m1"><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mtr><mtd class="ltx_align_left" columnalign="left"><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><mrow><mn>2</mn><mo>⁢</mo><mrow><mo>(</mo><mrow><msup><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>)</mo></mrow><mo>⁢</mo><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></mrow></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>=</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi></mrow></mtd></mtr><mtr><mtd class="ltx_align_left" columnalign="left"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow></mtd></mtr></mtable></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(13)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">and where <math alttext="\mathbf{u}^{\mathsf{T}}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m5"><msup><mi>𝐮</mi><mi>𝖳</mi></msup></math> denotes the transpose of <math alttext="\mathbf{u}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m6"><mi>𝐮</mi></math>.
Since targets are modeled as points, condition (<a class="ltx_ref" href="#E12" title="In Specular Reflection and Refraction ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">12</span></a>) effectively occurs with zero probability, and, consequently, the path (<a class="ltx_ref" href="#E11" title="In Diffuse Reflection ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">11</span></a>) is not a valid path.
However, the specular suffix <math alttext="p_{n}^{(\ell_{d}:)}" class="ltx_math_unparsed" display="inline" id="SS1.SSS0.Px2.p1.m7"><msubsup><mi>p</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo lspace="0.278em" rspace="0em">:</mo><mo stretchy="false">)</mo></mrow></msubsup></math>, where <math alttext="\ell_{d}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m8"><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub></math> is defined as in (<a class="ltx_ref" href="S2.html#E10" title="In 2.4 Ray Tubes ‣ 2 Essential Concepts and Terminology ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a>), can be further processed to determine vertices <math alttext="\left(\widetilde{\mathbf{v}}_{n}^{(\ell_{d}+1)},\cdots,\widetilde{\mathbf{v}}_%
{n}^{(\ell)}\right)" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p1.m9"><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></math> such that</p>
<table class="ltx_equation ltx_eqn_table" id="E14">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\widetilde{p}_{n}^{(\ell)}=\Bigg{(}\mathbf{s},\left(\mathbf{v}_{n}^{(1)},o_{n}%
^{(1)},m_{n}^{(1)},\chi_{n}^{(1)}\right),\cdots,\\
\underbrace{\left(\widetilde{\mathbf{v}}_{n}^{(\ell_{d}+1)},o_{n}^{(\ell_{d}+1%
)},m_{n}^{(\ell_{d}+1)},\chi_{n}^{(\ell_{d}+1)}\right),\cdots,\left(\widetilde%
{\mathbf{v}}_{n}^{(\ell)},o_{n}^{(\ell)},m_{n}^{(\ell)},\chi_{n}^{(\ell)}%
\right),\mathbf{t}_{k}}_{\text{Processed specular suffix}}\Bigg{)}" class="ltx_Math" display="block" id="E14.m1"><mtable displaystyle="true" rowspacing="0pt"><mtr><mtd class="ltx_align_left" columnalign="left"><mrow><msubsup><mover accent="true"><mi>p</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo maxsize="260%" minsize="260%">(</mo><mi>𝐬</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo></mrow></mrow></mtd></mtr><mtr><mtd class="ltx_align_right" columnalign="right"><mrow><munder><munder accentunder="true"><mrow><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><msub><mi>𝐭</mi><mi>k</mi></msub></mrow><mo>⏟</mo></munder><mtext>Processed specular suffix</mtext></munder><mo maxsize="260%" minsize="260%">)</mo></mrow></mtd></mtr></mtable></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(14)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">is a valid path, as illustrated in Figure <a class="ltx_ref" href="#F12" title="Figure 12 ‣ Specular Reflection and Refraction ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">12</span></a>.
This additional processing is performed using the image method in the algorithm described in Section <a class="ltx_ref" href="#SS2" title="3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.2</span></a>.</p>
</div>
<figure class="ltx_figure" id="F12"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="249" id="F12.g1" src="x13.png" width="457"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 12</span>: </span><span class="ltx_text" style="font-size:90%;">Processing a candidate specular chain of depth <math alttext="\ell=2" class="ltx_Math" display="inline" id="F12.m4"><mrow><mi mathvariant="normal">ℓ</mi><mo>=</mo><mn>2</mn></mrow></math> (<math alttext="p_{n}^{(2)}" class="ltx_Math" display="inline" id="F12.m5"><msubsup><mi>p</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup></math>, dashed line) to produce a valid path (<math alttext="\widetilde{p}_{n}^{(2)}" class="ltx_Math" display="inline" id="F12.m6"><msubsup><mover accent="true"><mi>p</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup></math>, solid line). The same process applies to specular suffixes. Shown in 2D for clarity.</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.SSS0.Px2.p2">
<p class="ltx_p">Importantly, for a sequence of primitives and interaction types</p>
<table class="ltx_equation ltx_eqn_table" id="E15">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\left(\mathbf{v}_{n}^{(\ell_{d})},\left(o_{n}^{(\ell_{d}+1)},m_{n}^{(\ell_{d}+%
1)},\chi_{n}^{(\ell_{d}+1)}\right),\cdots,\left(o_{n}^{(\ell)},m_{n}^{(\ell)},%
\chi_{n}^{(\ell)}\right),\mathbf{t}_{i}\right)" class="ltx_Math" display="block" id="E15.m1"><mrow><mo>(</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><msub><mi>𝐭</mi><mi>i</mi></msub><mo>)</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(15)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math alttext="\mathbf{v}_{n}^{(0)}=\mathbf{s}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m1"><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi>𝐬</mi></mrow></math>, there exists <em class="ltx_emph ltx_font_italic">at most a single</em> set of vertices <math alttext="\widetilde{\mathbf{v}}_{n}^{(\ell_{d}+1)},\cdots,\widetilde{\mathbf{v}}_{n}^{(%
\ell)}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m2"><mrow><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math> such that <math alttext="\widetilde{p}_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m3"><msubsup><mover accent="true"><mi>p</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is a valid path.
Consequently, if <math alttext="\ell_{d}=0" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m4"><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>=</mo><mn>0</mn></mrow></math>, i.e. <math alttext="p_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m5"><msubsup><mi>p</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is a specular chain, then further processing by the image method of multiple identical candidates (<a class="ltx_ref" href="#E15" title="In Specular Reflection and Refraction ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">15</span></a>) would result in multiple identical valid paths, which would lead to erroneous <a href="#glo.acronym.CIR"><span class="ltx_glossaryref" href="#glo.acronym.CIR" title="channel impulse response">CIRs</span></a>.
Therefore, if the sample <math alttext="p_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m6"><msubsup><mi>p</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is a specular chain, a hashing-based de-duplication mechanism, detailed in Section <a class="ltx_ref" href="#SS1.SSS3" title="3.1.3 Hashing of Specular Chains ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.3</span></a>, ensures that specular chain candidates are only evaluated once.
Notably, the path hashing mechanism discards redundant candidates “on-the-fly”, significantly reducing memory and compute requirements.
However, when <math alttext="\ell_{d}&gt;0" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m7"><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>&gt;</mo><mn>0</mn></mrow></math>, then <math alttext="\mathbf{v}_{n}^{(\ell_{d})}" class="ltx_Math" display="inline" id="SS1.SSS0.Px2.p2.m8"><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow></msubsup></math> corresponds to a diffuse reflection point that is the result of a randomly sampled ray direction (either at the source or the last previous diffuse reflection point).
Since the probability of two different paths having identical randomly sampled diffuse reflection points is effectively zero, path uniqueness is guaranteed in these cases without requiring the de-duplication mechanism.
As shown in Figure <a class="ltx_ref" href="#F10" title="Figure 10 ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a>, a <a href="#glo.acronym.LoS"><span class="ltx_glossaryref" href="#glo.acronym.LoS" title="line-of-sight">LoS</span></a> occlusion test to the target is used as a heuristic to discard path candidates that have little chance of resulting in a valid path after processing by the image method-based algorithm.
Finally, a new ray is traced into the direction (<a class="ltx_ref" href="#E13" title="In Specular Reflection and Refraction ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">13</span></a>) to continue the sample path.</p>
</div>
<div class="ltx_para" id="SS1.SSS0.Px2.p3">
<p class="ltx_p">The candidate generator depicted in Figure <a class="ltx_ref" href="#F10" title="Figure 10 ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a> thus yields a set of valid paths connecting the source to all targets that do not require further processing (except for the computation of the corresponding path coefficients and delays) and end with a diffuse reflection.
Additionally, it produces a set of candidate paths ending with specular suffixes, which require further processing to be either discarded or refined into valid paths.
The path solver constructs paths that may include any combination and number of specular reflections, diffuse reflections, and refractions.</p>
</div>
</section>
<section class="ltx_subsubsection" id="SS1.SSS1">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.1.1 </span>Sampling Initial Ray Directions</h3>
<div class="ltx_para" id="SS1.SSS1.p1">
<p class="ltx_p">The <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> procedure starts by spawning rays from the source with directions obtained from a spherical Fibonacci lattice with <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m1"><msub><mi>N</mi><mi>S</mi></msub></math> points, which is defined as follows:</p>
<table class="ltx_equation ltx_eqn_table" id="E16">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\widehat{\mathbf{k}}_{n}^{(0)}=\begin{bmatrix}\sin{\theta_{n}}\cos{\phi_{n}}\\
\sin{\theta_{n}}\sin{\phi_{n}}\\
\cos{\theta_{n}}\end{bmatrix}" class="ltx_Math" display="block" id="E16.m1"><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>[</mo><mtable displaystyle="true" rowspacing="0pt"><mtr><mtd><mrow><mrow><mi>sin</mi><mo lspace="0.167em">⁡</mo><msub><mi>θ</mi><mi>n</mi></msub></mrow><mo lspace="0.167em">⁢</mo><mrow><mi>cos</mi><mo lspace="0.167em">⁡</mo><msub><mi>ϕ</mi><mi>n</mi></msub></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mi>sin</mi><mo lspace="0.167em">⁡</mo><msub><mi>θ</mi><mi>n</mi></msub></mrow><mo lspace="0.167em">⁢</mo><mrow><mi>sin</mi><mo lspace="0.167em">⁡</mo><msub><mi>ϕ</mi><mi>n</mi></msub></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi>cos</mi><mo lspace="0.167em">⁡</mo><msub><mi>θ</mi><mi>n</mi></msub></mrow></mtd></mtr></mtable><mo>]</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(16)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where</p>
<table class="ltx_equationgroup ltx_eqn_eqnarray ltx_eqn_table" id="A1.EGx1">
<tbody id="Ex1"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\theta_{n}" class="ltx_Math" display="inline" id="Ex1.m1"><msub><mi>θ</mi><mi>n</mi></msub></math></td>
<td class="ltx_td ltx_align_center ltx_eqn_cell"><math alttext="\displaystyle=" class="ltx_Math" display="inline" id="Ex1.m2"><mo>=</mo></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle\arccos{\frac{2n}{N_{S}}}" class="ltx_Math" display="inline" id="Ex1.m3"><mrow><mi>arccos</mi><mo lspace="0.167em">⁡</mo><mstyle displaystyle="true"><mfrac><mrow><mn>2</mn><mo>⁢</mo><mi>n</mi></mrow><msub><mi>N</mi><mi>S</mi></msub></mfrac></mstyle></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="Ex2"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\phi_{n}" class="ltx_Math" display="inline" id="Ex2.m1"><msub><mi>ϕ</mi><mi>n</mi></msub></math></td>
<td class="ltx_td ltx_align_center ltx_eqn_cell"><math alttext="\displaystyle=" class="ltx_Math" display="inline" id="Ex2.m2"><mo>=</mo></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle 2\pi\frac{n}{\varphi}" class="ltx_Math" display="inline" id="Ex2.m3"><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi><mo>⁢</mo><mstyle displaystyle="true"><mfrac><mi>n</mi><mi>φ</mi></mfrac></mstyle></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">and <math alttext="-\left\lfloor\frac{N_{S}}{2}\right\rfloor\leq n\leq\left\lceil\frac{N_{S}}{2}%
\right\rceil-1" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m2"><mrow><mrow><mo>−</mo><mrow><mo>⌊</mo><mfrac><msub><mi>N</mi><mi>S</mi></msub><mn>2</mn></mfrac><mo>⌋</mo></mrow></mrow><mo>≤</mo><mi>n</mi><mo>≤</mo><mrow><mrow><mo>⌈</mo><mfrac><msub><mi>N</mi><mi>S</mi></msub><mn>2</mn></mfrac><mo>⌉</mo></mrow><mo>−</mo><mn>1</mn></mrow></mrow></math>, <math alttext="\varphi=\frac{1+\sqrt{5}}{2}" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m3"><mrow><mi>φ</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac></mrow></math> is the golden ratio, and <math alttext="\left\lfloor\cdot\right\rfloor" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m4"><mrow><mo>⌊</mo><mo lspace="0em" rspace="0em">⋅</mo><mo>⌋</mo></mrow></math> and <math alttext="\left\lceil\cdot\right\rceil" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m5"><mrow><mo>⌈</mo><mo lspace="0em" rspace="0em">⋅</mo><mo>⌉</mo></mrow></math> the floor and ceiling function, respectively.
Note that when defining the Fibonacci lattice, the index <math alttext="n" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m6"><mi>n</mi></math> takes values in the range <math alttext="-\left\lfloor\frac{N_{S}}{2}\right\rfloor,\dots,\left\lceil\frac{N_{S}}{2}%
\right\rceil-1" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m7"><mrow><mrow><mo>−</mo><mrow><mo>⌊</mo><mfrac><msub><mi>N</mi><mi>S</mi></msub><mn>2</mn></mfrac><mo>⌋</mo></mrow></mrow><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mrow><mo>⌈</mo><mfrac><msub><mi>N</mi><mi>S</mi></msub><mn>2</mn></mfrac><mo>⌉</mo></mrow><mo>−</mo><mn>1</mn></mrow></mrow></math> instead of the usual <math alttext="1,\dots,N_{S}" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m8"><mrow><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>N</mi><mi>S</mi></msub></mrow></math>.
Sampling rays from the Fibonacci lattice results in ray tubes sharing approximately the same opening angle <math alttext="\frac{4\pi}{N_{S}}" class="ltx_Math" display="inline" id="SS1.SSS1.p1.m9"><mfrac><mrow><mn>4</mn><mo>⁢</mo><mi>π</mi></mrow><msub><mi>N</mi><mi>S</mi></msub></mfrac></math>.</p>
</div>
<figure class="ltx_figure" id="F13">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_3">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F13.sf1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="611" id="F13.sf1.g1" src="figures/path-solver-fibo-100.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(a)</span> </span><span class="ltx_text" style="font-size:90%;">100 points.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_3">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F13.sf2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="611" id="F13.sf2.g1" src="figures/path-solver-fibo-1000.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(b)</span> </span><span class="ltx_text" style="font-size:90%;">1000 points.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_3">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F13.sf3"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="611" id="F13.sf3.g1" src="figures/path-solver-fibo-10000.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(c)</span> </span><span class="ltx_text" style="font-size:90%;">10000 points.</span></figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 13</span>: </span><span class="ltx_text" style="font-size:90%;">Spherical Fibonacci lattice.</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.SSS1.p2">
<p class="ltx_p">The Fibonacci lattice was selected for its simple construction and its benefits over other lattices for numerical integration <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="bib.html#bib12" title="">12</a>, <a class="ltx_ref" href="bib.html#bib13" title="">13</a>]</cite>.
Figure <a class="ltx_ref" href="#F13" title="Figure 13 ‣ 3.1.1 Sampling Initial Ray Directions ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">13</span></a> shows the spherical Fibonacci lattice with 100, 1000, and 10000 points.
The Sionna RT path solver uses <math alttext="10^{6}" class="ltx_Math" display="inline" id="SS1.SSS1.p2.m1"><msup><mn>10</mn><mn>6</mn></msup></math> points as the default value for <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS1.SSS1.p2.m2"><msub><mi>N</mi><mi>S</mi></msub></math>, and higher values will ensure that more valid paths are found.</p>
</div>
</section>
<section class="ltx_subsubsection" id="SS1.SSS2">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.1.2 </span>Sampling Interaction Types</h3>
<div class="ltx_para" id="SS1.SSS2.p1">
<p class="ltx_p">Within the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop, when a ray intersects the scene geometry, the algorithm generates at most one scattered ray. This constraint is necessary because generating multiple rays at each intersection, such as both reflected and refracted rays, would lead to an exponential increase in computational complexity and memory usage with the depth of the path. Instead, a single interaction type is randomly chosen based on a distribution:</p>
<table class="ltx_equation ltx_eqn_table" id="E17">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="{\cal Q}=\left\{q\left({\cal R}\right),q\left({\cal S}\right),q\left({\cal T}%
\right)\right\},\qquad\text{where }q\left({\cal R}\right)+q\left({\cal S}%
\right)+q\left({\cal T}\right)=1\text{ and }q\left(\cdot\right)\geq 0." class="ltx_Math" display="block" id="E17.m1"><mrow><mrow><mrow><mi class="ltx_font_mathcaligraphic">𝒬</mi><mo>=</mo><mrow><mo>{</mo><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi><mo>)</mo></mrow></mrow><mo>,</mo><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">𝒮</mi><mo>)</mo></mrow></mrow><mo>,</mo><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>)</mo></mrow></mrow><mo>}</mo></mrow></mrow><mo rspace="2.167em">,</mo><mrow><mrow><mrow><mtext>where </mtext><mo>⁢</mo><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">𝒮</mi><mo>)</mo></mrow></mrow><mo>+</mo><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>⁢</mo><mtext> and </mtext><mo>⁢</mo><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mo lspace="0em" rspace="0em">⋅</mo><mo>)</mo></mrow></mrow><mo>≥</mo><mn>0</mn></mrow></mrow><mo lspace="0em">.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(17)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">Here, <math alttext="q\left(\chi\right)" class="ltx_Math" display="inline" id="SS1.SSS2.p1.m1"><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi>χ</mi><mo>)</mo></mrow></mrow></math> represents the probability of selecting the interaction type <math alttext="\chi\in{\cal I}" class="ltx_Math" display="inline" id="SS1.SSS2.p1.m2"><mrow><mi>χ</mi><mo>∈</mo><mi class="ltx_font_mathcaligraphic">ℐ</mi></mrow></math>. Importantly, the choice of distribution <math alttext="{\cal Q}" class="ltx_Math" display="inline" id="SS1.SSS2.p1.m3"><mi class="ltx_font_mathcaligraphic">𝒬</mi></math> does not affect the correctness of the calculated paths, which are solely dependent on the propagation environment. However, the choice of distribution <math alttext="{\cal Q}" class="ltx_Math" display="inline" id="SS1.SSS2.p1.m4"><mi class="ltx_font_mathcaligraphic">𝒬</mi></math> significantly impacts the <em class="ltx_emph ltx_font_italic">sample efficiency</em> of the ray tracer, which is the number of samples <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS1.SSS2.p1.m5"><msub><mi>N</mi><mi>S</mi></msub></math> needed to compute paths that connect a source to a target and capture the majority of the transported energy.
Sampling only one interaction type per intersection may appear limiting, but this is offset by the large number of samples generated from each source. In most scenarios, a high sample count allows for identifying all significant paths.</p>
</div>
<div class="ltx_para" id="SS1.SSS2.p2">
<p class="ltx_p">For each sample <math alttext="n" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m1"><mi>n</mi></math> at depth <math alttext="\ell" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m2"><mi mathvariant="normal">ℓ</mi></math>, the interaction type is sampled independently from other interactions and such that the probability of sampling each event type is proportional to the squared amplitudes of the reflection and refraction coefficients:</p>
<table class="ltx_equationgroup ltx_eqn_table" id="E18">
<tbody>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E18X">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle q\left({\cal R}\right)" class="ltx_Math" display="inline" id="E18X.m2"><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi><mo>)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=R^{2}\frac{\left|r_{\perp}\right|^{2}+\left|r_{\parallel}\right|%
^{2}}{\left|r_{\perp}\right|^{2}+\left|r_{\parallel}\right|^{2}+\left|t_{\perp%
}\right|^{2}+\left|t_{\parallel}\right|^{2}}" class="ltx_Math" display="inline" id="E18X.m3"><mrow><mi></mi><mo>=</mo><mrow><msup><mi>R</mi><mn>2</mn></msup><mo>⁢</mo><mstyle displaystyle="true"><mfrac><mrow><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup></mrow><mrow><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup></mrow></mfrac></mstyle></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="3"><span class="ltx_tag ltx_tag_equationgroup ltx_align_right">(18)</span></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E18Xa">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle q\left({\cal S}\right)" class="ltx_Math" display="inline" id="E18Xa.m2"><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">𝒮</mi><mo>)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=S^{2}\frac{\left|r_{\perp}\right|^{2}+\left|r_{\parallel}\right|%
^{2}}{\left|r_{\perp}\right|^{2}+\left|r_{\parallel}\right|^{2}+\left|t_{\perp%
}\right|^{2}+\left|t_{\parallel}\right|^{2}}" class="ltx_Math" display="inline" id="E18Xa.m3"><mrow><mi></mi><mo>=</mo><mrow><msup><mi>S</mi><mn>2</mn></msup><mo>⁢</mo><mstyle displaystyle="true"><mfrac><mrow><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup></mrow><mrow><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup></mrow></mfrac></mstyle></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E18Xb">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle q\left({\cal T}\right)" class="ltx_Math" display="inline" id="E18Xb.m2"><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>)</mo></mrow></mrow></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=\frac{\left|t_{\perp}\right|^{2}+\left|t_{\parallel}\right|^{2}}%
{\left|r_{\perp}\right|^{2}+\left|r_{\parallel}\right|^{2}+\left|t_{\perp}%
\right|^{2}+\left|t_{\parallel}\right|^{2}}" class="ltx_Math" display="inline" id="E18Xb.m3"><mrow><mi></mi><mo>=</mo><mstyle displaystyle="true"><mfrac><mrow><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup></mrow><mrow><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>r</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>⟂</mo></msub><mo>|</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo>|</mo><msub><mi>t</mi><mo>∥</mo></msub><mo>|</mo></mrow><mn>2</mn></msup></mrow></mfrac></mstyle></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</tbody>
</table>
<p class="ltx_p">Here, <math alttext="r_{\perp}" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m3"><msub><mi>r</mi><mo>⟂</mo></msub></math>, <math alttext="r_{\parallel}" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m4"><msub><mi>r</mi><mo>∥</mo></msub></math>, <math alttext="t_{\perp}" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m5"><msub><mi>t</mi><mo>⟂</mo></msub></math>, and <math alttext="t_{\parallel}" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m6"><msub><mi>t</mi><mo>∥</mo></msub></math> are the Fresnel coefficients (<a class="ltx_ref" href="A1.html#E116" title="In A.7.1 Single-Layer Slab ‣ A.7 Specular Reflection and Refraction ‣ Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">116</span></a>), <math alttext="S" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m7"><mi>S</mi></math> is the scattering coefficient (see Section <a class="ltx_ref" href="A1.html#SS8" title="A.8 Diffuse Reflection ‣ Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">A.8</span></a>), and <math alttext="R" class="ltx_Math" display="inline" id="SS1.SSS2.p2.m8"><mi>R</mi></math> is the reflection reduction factor (<a class="ltx_ref" href="A1.html#E119" title="In A.8 Diffuse Reflection ‣ Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">119</span></a>). This approach ensures that the interaction types that scatter more energy are sampled more frequently–a technique known as <em class="ltx_emph ltx_font_italic">importance sampling</em> <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="bib.html#bib14" title="">14</a>]</cite>.
This is similar to techniques for importance sampling of light transport paths as used in computer graphics.</p>
</div>
<figure class="ltx_figure" id="F14">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F14.sf1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="457" id="F14.sf1.g1" src="figures/importance-sampling-uniform-heuristic-scene.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(a)</span> </span><span class="ltx_text" style="font-size:90%;">Scene used for the comparison.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F14.sf2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="655" id="F14.sf2.g1" src="x14.png" width="830"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(b)</span> </span><span class="ltx_text" style="font-size:90%;">Channel gain at the target.</span></figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 14</span>: </span><span class="ltx_text" style="font-size:90%;">Comparison of sampling strategies for interaction types. The scene consists of a closed metallic box containing a glass screen, with a source (red ball) and target (green ball) on opposite sides. The box is shown open to visualize the interior. Importance sampling achieves faster convergence of the channel gain compared to uniform sampling.</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.SSS2.p3">
<p class="ltx_p">To illustrate the importance of optimized sampling strategies, we compare uniform sampling, where each interaction type is selected with equal probability, to importance sampling using the scene shown in Figure <a class="ltx_ref" href="#F14.sf1" title="In Figure 14 ‣ 3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">14(a)</span></a>. The scene consists of a metallic box containing a glass screen, with a source and target positioned on opposite sides.
Diffuse reflection, specular reflection, and refraction are enabled, and the maximum depth <math alttext="L" class="ltx_Math" display="inline" id="SS1.SSS2.p3.m1"><mi>L</mi></math> is set to <math alttext="5" class="ltx_Math" display="inline" id="SS1.SSS2.p3.m2"><mn>5</mn></math>.
As shown in Figure <a class="ltx_ref" href="#F14.sf2" title="In Figure 14 ‣ 3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">14(b)</span></a>, using importance sampling leads to better sample efficiency when compared to uniform sampling, as convergence requires approximately <math alttext="100\times" class="ltx_math_unparsed" display="inline" id="SS1.SSS2.p3.m3"><mrow><mn>100</mn><mo lspace="0.222em">×</mo></mrow></math> less samples to capture most of the received energy. This demonstrates the benefit of selecting interactions according to the material properties of the scatterers.</p>
</div>
</section>
<section class="ltx_subsubsection" id="SS1.SSS3">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.1.3 </span>Hashing of Specular Chains</h3>
<div class="ltx_para" id="SS1.SSS3.p1">
<p class="ltx_p">As mentioned in Section <a class="ltx_ref" href="#SS1" title="3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1</span></a> and illustrated in Figure <a class="ltx_ref" href="#F10" title="Figure 10 ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a>, to avoid storing multiple identical specular chain candidates, a path hashing method is used to discard duplicates of previously found candidates “on-the-fly”.
Recall that a specular chain candidate is defined by a sequence of interactions with the scene, each characterized by the intersected object <math alttext="o_{n}^{(\ell)}\in\mathbb{N}_{0}" class="ltx_Math" display="inline" id="SS1.SSS3.p1.m1"><mrow><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><msub><mi>ℕ</mi><mn>0</mn></msub></mrow></math>, the corresponding intersected primitive <math alttext="m_{n}^{(\ell)}\in\mathbb{N}_{0}" class="ltx_Math" display="inline" id="SS1.SSS3.p1.m2"><mrow><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><msub><mi>ℕ</mi><mn>0</mn></msub></mrow></math>, and the interaction type <math alttext="\chi_{n}^{(\ell)}\in{\cal I}" class="ltx_Math" display="inline" id="SS1.SSS3.p1.m3"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>∈</mo><mi class="ltx_font_mathcaligraphic">ℐ</mi></mrow></math>, as in (<a class="ltx_ref" href="#E15" title="In Specular Reflection and Refraction ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">15</span></a>) with <math alttext="\ell_{d}=0" class="ltx_Math" display="inline" id="SS1.SSS3.p1.m4"><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>=</mo><mn>0</mn></mrow></math>, i.e.</p>
<table class="ltx_equation ltx_eqn_table" id="E19">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="c^{(\ell)}_{n}=\left(\mathbf{s},\left(o_{n}^{(1)},m_{n}^{(1)},\chi_{n}^{(1)}%
\right),\cdots,\left(o_{n}^{(\ell)},m_{n}^{(\ell)},\chi_{n}^{(\ell)}\right)%
\right)." class="ltx_Math" display="block" id="E19.m1"><mrow><mrow><msubsup><mi>c</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mi>𝐬</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>)</mo></mrow></mrow><mo lspace="0em">.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(19)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">For specular chain candidates, we do not need to store the path vertices. If the candidate leads to a valid path, these vertices will be computed. Invalid candidates will be discarded.</p>
</div>
<figure class="ltx_float ltx_float_algorithm ltx_framed ltx_framed_top" id="alg1">
<div class="ltx_listing ltx_align_center ltx_listing">
<div class="ltx_listingline" id="alg0.l1">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">1:</span></span>
<math alttext="\texttt{hash}_{n}^{(0)}\leftarrow 0" class="ltx_Math" display="inline" id="alg0.l1.m1"><mrow><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>0</mn></mrow></math>
</div>
<div class="ltx_listingline" id="alg0.l2">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">2:</span></span>
<math alttext="\ell\leftarrow 1" class="ltx_Math" display="inline" id="alg0.l2.m1"><mrow><mi mathvariant="normal">ℓ</mi><mo stretchy="false">←</mo><mn>1</mn></mrow></math>
</div>
<div class="ltx_listingline" id="alg0.l3">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">3:</span></span>
<span class="ltx_text ltx_font_bold">while</span> &lt;Stop condition&gt; <span class="ltx_text ltx_font_bold">do</span> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg0.l3.m1"><mo>▷</mo></math> <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop
</span>
</div>
<div class="ltx_listingline" id="alg0.l4">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">4:</span></span>
                
                
                   <math alttext="\cdots" class="ltx_Math" display="inline" id="alg0.l4.m1"><mi mathvariant="normal">⋯</mi></math>
</div>
<div class="ltx_listingline" id="alg0.l5">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">5:</span></span>
                
                
                   <math alttext="\texttt{inter\_hash}_{n}^{(\ell)}\leftarrow\textsc{hash\_intersection}(o_{n}^{%
(\ell)},m_{n}^{(\ell)},\chi_{n}^{(\ell)})" class="ltx_Math" display="inline" id="alg0.l5.m1"><mrow><msubsup><mtext class="ltx_mathvariant_monospace">inter_hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">hash_intersection</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg0.l6">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">6:</span></span>
                
                
                   <math alttext="\texttt{hash}_{n}^{(\ell)}\leftarrow\textsc{hash\_update}(\texttt{hash}_{n}^{(%
\ell-1)},\texttt{inter\_hash}_{n}^{(\ell)})" class="ltx_Math" display="inline" id="alg0.l6.m1"><mrow><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">hash_update</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mtext class="ltx_mathvariant_monospace">inter_hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg0.l7">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">7:</span></span>
                
                
                   <math alttext="\cdots" class="ltx_Math" display="inline" id="alg0.l7.m1"><mi mathvariant="normal">⋯</mi></math>
</div>
<div class="ltx_listingline" id="alg0.l8">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">8:</span></span>
                
                
                   <math alttext="\ell\leftarrow\ell+1" class="ltx_Math" display="inline" id="alg0.l8.m1"><mrow><mi mathvariant="normal">ℓ</mi><mo stretchy="false">←</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg0.l9">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">9:</span></span>
<span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">while</span>
</div>
<div class="ltx_listingline" id="alg0.l10">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">10:</span></span>
</div>
<div class="ltx_listingline" id="alg0.l11">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">11:</span></span>
<span class="ltx_text ltx_font_bold">procedure</span> <span class="ltx_text ltx_font_smallcaps">hash_intersection</span>(<math alttext="o,m,s" class="ltx_Math" display="inline" id="alg0.l11.m1"><mrow><mi>o</mi><mo>,</mo><mi>m</mi><mo>,</mo><mi>s</mi></mrow></math>)

</div>
<div class="ltx_listingline" id="alg0.l12">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">12:</span></span>
                
                
                   <math alttext="h_{1}\leftarrow\textsc{cantor\_pair}(o,m)" class="ltx_Math" display="inline" id="alg0.l12.m1"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">cantor_pair</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>o</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg0.l12.m2"><mo>▷</mo></math> Pair object and primitive
</span>
</div>
<div class="ltx_listingline" id="alg0.l13">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">13:</span></span>
                
                
                   <math alttext="h_{2}\leftarrow\textsc{cantor\_pair}(h_{1},s)" class="ltx_Math" display="inline" id="alg0.l13.m1"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">cantor_pair</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg0.l13.m2"><mo>▷</mo></math> Pair with interaction type
</span>
</div>
<div class="ltx_listingline" id="alg0.l14">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">14:</span></span>
                
                
                   <span class="ltx_text ltx_font_bold">return</span> <math alttext="h_{2}" class="ltx_Math" display="inline" id="alg0.l14.m1"><msub><mi>h</mi><mn>2</mn></msub></math>
</div>
<div class="ltx_listingline" id="alg0.l15">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">15:</span></span>
<span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">procedure</span>
</div>
<div class="ltx_listingline" id="alg0.l16">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">16:</span></span>
</div>
<div class="ltx_listingline" id="alg0.l17">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">17:</span></span>
<span class="ltx_text ltx_font_bold">procedure</span> <span class="ltx_text ltx_font_smallcaps">hash_update</span>(<math alttext="\texttt{curr\_hash},\texttt{inter\_hash}" class="ltx_Math" display="inline" id="alg0.l17.m1"><mrow><mtext class="ltx_mathvariant_monospace">curr_hash</mtext><mo>,</mo><mtext class="ltx_mathvariant_monospace">inter_hash</mtext></mrow></math>)

</div>
<div class="ltx_listingline" id="alg0.l18">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">18:</span></span>
                
                
                   <span class="ltx_text ltx_font_bold">return</span> <math alttext="(1373\cdot\texttt{curr\_hash}+\texttt{inter\_hash})" class="ltx_Math" display="inline" id="alg0.l18.m1"><mrow><mo stretchy="false">(</mo><mrow><mrow><mn>1373</mn><mo lspace="0.222em" rspace="0.222em">⋅</mo><mtext class="ltx_mathvariant_monospace">curr_hash</mtext></mrow><mo>+</mo><mtext class="ltx_mathvariant_monospace">inter_hash</mtext></mrow><mo stretchy="false">)</mo></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg0.l18.m2"><mo>▷</mo></math> Update rolling hash
</span>
</div>
<div class="ltx_listingline" id="alg0.l19">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">19:</span></span>
<span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">procedure</span>
</div>
<div class="ltx_listingline" id="alg0.l20">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">20:</span></span>
</div>
<div class="ltx_listingline" id="alg0.l21">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">21:</span></span>
<span class="ltx_text ltx_font_bold">procedure</span> <span class="ltx_text ltx_font_smallcaps">cantor_pair</span>(<math alttext="x,y" class="ltx_Math" display="inline" id="alg0.l21.m1"><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow></math>)

</div>
<div class="ltx_listingline" id="alg0.l22">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">22:</span></span>
                
                
                   <math alttext="z\leftarrow\frac{x^{2}+x+2xy+3y+y^{2}}{2}" class="ltx_Math" display="inline" id="alg0.l22.m1"><mrow><mi>z</mi><mo stretchy="false">←</mo><mfrac><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mrow><mn>2</mn><mo>⁢</mo><mi>x</mi><mo>⁢</mo><mi>y</mi></mrow><mo>+</mo><mrow><mn>3</mn><mo>⁢</mo><mi>y</mi></mrow><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mn>2</mn></mfrac></mrow></math>
</div>
<div class="ltx_listingline" id="alg0.l23">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">23:</span></span>
                
                
                   <span class="ltx_text ltx_font_bold">return</span> <math alttext="z" class="ltx_Math" display="inline" id="alg0.l23.m1"><mi>z</mi></math>
</div>
<div class="ltx_listingline" id="alg0.l24">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">24:</span></span>
<span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">procedure</span>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold">Algorithm 1</span> </span> Hashing of specular chains</figcaption>
</figure>
<div class="ltx_para" id="SS1.SSS3.p2">
<p class="ltx_p">Algorithm <a class="ltx_ref" href="#alg1" title="Algorithm 1 ‣ 3.1.3 Hashing of Specular Chains ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">1</span></a> demonstrates how path hashing works during ray tracing to avoid duplicate specular chain candidates.
It starts by initializing a hash value <math alttext="\texttt{hash}_{n}^{(0)}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m1"><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> to <math alttext="0" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m2"><mn>0</mn></math> for each sample <math alttext="n=1,\dots,N_{S}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m3"><mrow><mi>n</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>N</mi><mi>S</mi></msub></mrow></mrow></math> being traced.
Then, as the sample interacts with objects in the scene, the algorithm computes a hash value <math alttext="\texttt{inter\_hash}_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m4"><msubsup><mtext class="ltx_mathvariant_monospace">inter_hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> for each intersection based on the object that was hit <math alttext="o_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m5"><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>, the specific primitive of that object <math alttext="m_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m6"><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>, and the type of interaction <math alttext="\chi_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m7"><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>.
The overall path hash <math alttext="\texttt{hash}_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.p2.m8"><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> gets updated by combining it with the hash of each new intersection, creating a unique identifier for the entire sample up to that point.</p>
</div>
<div class="ltx_para" id="SS1.SSS3.p3">
<p class="ltx_p">Computing the hash after a given intersection is implemented by combining the three components of an intersection into a single hash value through a two-step process using the <em class="ltx_emph ltx_font_italic">Cantor pairing function</em>.
The Cantor pairing function is a mapping between pairs of natural numbers and single natural numbers <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="bib.html#bib15" title="">15</a>]</cite>.
This bijective function guarantees that distinct input pairs always yield distinct output values, making it suitable for combining multiple values into a single hash.
Hashing of the interaction first pairs the object and primitive indices, then combines the resulting value with the interaction type.</p>
</div>
<div class="ltx_para" id="SS1.SSS3.p4">
<p class="ltx_p">The <span class="ltx_text ltx_font_smallcaps">hash_update</span> function updates the sample hash value <math alttext="\texttt{hash}_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.p4.m1"><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> through a polynomial rolling hash function <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="bib.html#bib16" title="">16</a>]</cite> with a prime base of <math alttext="1373" class="ltx_Math" display="inline" id="SS1.SSS3.p4.m2"><mn>1373</mn></math>.
For each new intersection, it updates the running hash by multiplying the current hash value by the prime number and adding the new intersection hash.
When a specular chain candidate is considered for a target <math alttext="k\in\left\{1,\dots,N_{T}\right\}" class="ltx_Math" display="inline" id="SS1.SSS3.p4.m3"><mrow><mi>k</mi><mo>∈</mo><mrow><mo>{</mo><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>N</mi><mi>T</mi></msub><mo>}</mo></mrow></mrow></math>, the hash value of the candidate is paired with the target index <math alttext="k" class="ltx_Math" display="inline" id="SS1.SSS3.p4.m4"><mi>k</mi></math> to form a new hash value</p>
<table class="ltx_equation ltx_eqn_table" id="E20">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\texttt{hash}_{n,k}^{(\ell)}=\textsc{cantor\_pair}(\texttt{hash}_{n}^{(\ell)},%
k)." class="ltx_Math" display="block" id="E20.m1"><mrow><mrow><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mtext class="ltx_font_smallcaps">cantor_pair</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo lspace="0em">.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(20)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">This ensures that the specular chain candidate is unique for each target.</p>
</div>
<section class="ltx_paragraph" id="SS1.SSS3.Px1">
<h4 class="ltx_title ltx_title_paragraph">Practical Considerations</h4>
<div class="ltx_para" id="SS1.SSS3.Px1.p1">
<p class="ltx_p">To track information about previously encountered specular chains, an array of integers of size <math alttext="N_{H}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p1.m1"><msub><mi>N</mi><mi>H</mi></msub></math> is allocated in memory and initialized to zero, referred to as the <em class="ltx_emph ltx_font_italic">hash array</em>.
When considering a specular chain candidate for target <math alttext="k" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p1.m2"><mi>k</mi></math> with corresponding hash value <math alttext="\texttt{hash}_{n,k}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p1.m3"><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>, the corresponding index <math alttext="i_{n,k}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p1.m4"><msubsup><mi>i</mi><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> in the hash array is computed as</p>
<table class="ltx_equation ltx_eqn_table" id="E21">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="i_{n,k}^{(\ell)}=\texttt{hash}_{n,k}^{(\ell)}\mod N_{H}." class="ltx_Math" display="block" id="E21.m1"><mrow><mrow><msubsup><mi>i</mi><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><msubsup><mtext class="ltx_mathvariant_monospace">hash</mtext><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>mod</mo><msub><mi>N</mi><mi>H</mi></msub></mrow></mrow><mo lspace="0em">.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(21)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">If the hash array entry at index <math alttext="i_{n,k}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p1.m5"><msubsup><mi>i</mi><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is greater than zero, it indicates that this path has already been encountered and should be discarded.
Otherwise, the entry is incremented by one and the candidate is retained for further processing by the image method.
It is important to note that the index <math alttext="i_{n,k}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p1.m6"><msubsup><mi>i</mi><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is not guaranteed to be unique for different specular chains. When two different specular chains share the same index value despite being different, the path solver will discard one of them. Such an event is referred to as a <em class="ltx_emph ltx_font_italic">collision</em>, and can result in the discarding of valid paths.
However, when two candidates are identical, their indices values will also be identical.</p>
</div>
<figure class="ltx_figure" id="F15"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="397" id="F15.g1" src="x15.png" width="664"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 15</span>: </span><span class="ltx_text" style="font-size:90%;">The hash array is used to track encountered path candidates. New candidates are stored in the buffer if they haven’t been encountered before. Non-specular chains are added to the buffer without a uniqueness check (not depicted in the figure).</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.SSS3.Px1.p2">
<p class="ltx_p">Valid paths and candidates are stored in a buffer of size <math alttext="N_{B}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p2.m1"><msub><mi>N</mi><mi>B</mi></msub></math>. This buffer holds, for each path, the sequence of interaction types, vertices, intersected objects, primitives, and more. When a valid path is found or a candidate is identified as unique, indicated by its corresponding entry <math alttext="i_{n,k}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p2.m2"><msubsup><mi>i</mi><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> (<a class="ltx_ref" href="#E21" title="In Practical Considerations ‣ 3.1.3 Hashing of Specular Chains ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">21</span></a>) in the hash array being set to zero, the path data are stored in the buffer. It is important to note that the index <math alttext="i_{n,k}^{(\ell)}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p2.m3"><msubsup><mi>i</mi><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is solely used for indexing the hash array and not for storing path data in the buffer. Instead, path data are stored contiguously in the next available slot of the path buffer, as shown in Figure <a class="ltx_ref" href="#F15" title="Figure 15 ‣ Practical Considerations ‣ 3.1.3 Hashing of Specular Chains ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">15</span></a>. If the buffer becomes full, any newly found paths or candidates are discarded.
Discarding paths rather than overwriting existing ones is based on the reason that paths with lower depth, which are added to the buffer first as the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop advances from <math alttext="\ell=0" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p2.m4"><mrow><mi mathvariant="normal">ℓ</mi><mo>=</mo><mn>0</mn></mrow></math> to <math alttext="\ell=L" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p2.m5"><mrow><mi mathvariant="normal">ℓ</mi><mo>=</mo><mi>L</mi></mrow></math>, typically carry more energy and should not be replaced by higher depth paths when the buffer becomes full.
Consequently, the buffer size <math alttext="N_{B}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p2.m6"><msub><mi>N</mi><mi>B</mi></msub></math> determines the maximum number of paths and candidates that can be stored.</p>
</div>
<div class="ltx_para" id="SS1.SSS3.Px1.p3">
<p class="ltx_p">Due to the substantial amount of data stored for each path, setting <math alttext="N_{B}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m1"><msub><mi>N</mi><mi>B</mi></msub></math> to excessively high values can lead to memory issues. This necessitates separating the hash array size <math alttext="N_{H}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m2"><msub><mi>N</mi><mi>H</mi></msub></math> from the buffer size <math alttext="N_{B}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m3"><msub><mi>N</mi><mi>B</mi></msub></math>. This is because a small hash array size can increase the probability of different hash values mapping to the same array index through the modulo operation (<a class="ltx_ref" href="#E21" title="In Practical Considerations ‣ 3.1.3 Hashing of Specular Chains ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">21</span></a>), leading to collisions. To reduce the risk of collisions, <math alttext="N_{H}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m4"><msub><mi>N</mi><mi>H</mi></msub></math> is set to</p>
<table class="ltx_equation ltx_eqn_table" id="E22">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="N_{H}=\max\left(N_{B},10^{6}\right)" class="ltx_Math" display="block" id="E22.m1"><mrow><msub><mi>N</mi><mi>H</mi></msub><mo>=</mo><mrow><mi>max</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>N</mi><mi>B</mi></msub><mo>,</mo><msup><mn>10</mn><mn>6</mn></msup><mo>)</mo></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(22)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">ensuring a minimum array size of <math alttext="10^{6}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m5"><msup><mn>10</mn><mn>6</mn></msup></math> elements. In the interface of the Sionna RT built-in path solver, <math alttext="N_{B}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m6"><msub><mi>N</mi><mi>B</mi></msub></math> corresponds to the <span class="ltx_text ltx_markedasmath ltx_font_typewriter">samples_per_src</span> parameter, and <math alttext="N_{H}" class="ltx_Math" display="inline" id="SS1.SSS3.Px1.p3.m8"><msub><mi>N</mi><mi>H</mi></msub></math> corresponds to <span class="ltx_text ltx_markedasmath ltx_font_typewriter">max_num_paths_per_src</span>.</p>
</div>
</section>
</section>
<section class="ltx_subsubsection" id="SS1.SSS4">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.1.4 </span>Potential Improvements</h3>
<div class="ltx_para" id="SS1.SSS4.p1">
<p class="ltx_p">Several potential improvements can be made to enhance the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>-based candidate generator.
To begin with, optimizing the sampling of ray directions can be achieved by incorporating importance sampling based on the transmit antenna pattern for initial ray spawning and the scattering pattern for diffusely reflected rays. This approach is motivated by the substantial sample efficiency gains shown in Section <a class="ltx_ref" href="#SS1.SSS2" title="3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.2</span></a> through the use of importance sampling. By applying optimized sampling strategies for ray directions, further improvements may be realized as illustrated in Figure <a class="ltx_ref" href="#F16" title="Figure 16 ‣ 3.1.4 Potential Improvements ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">16</span></a>.</p>
</div>
<figure class="ltx_figure" id="F16"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="250" id="F16.g1" src="figures/path-solver-is-ant-pattern.png" width="329"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 16</span>: </span><span class="ltx_text" style="font-size:90%;">Gain of the 3GPP TR 38.901 <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="bib.html#bib17" title="">17</a>, Table 7.3-1]</cite> antenna pattern for each sample direction on a Fibonacci lattice with <math alttext="10^{4}" class="ltx_Math" display="inline" id="F16.m2"><msup><mn>10</mn><mn>4</mn></msup></math> points. The majority of sample directions exhibit low gain, indicating that importance sampling of ray directions may be beneficial.</span></figcaption>
</figure>
<figure class="ltx_figure" id="F17">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F17.sf1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="337" id="F17.sf1.g1" src="figures/simple-street-canyon-cam.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(a)</span> </span><span class="ltx_text" style="font-size:90%;">Considered scene.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F17.sf2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="564" id="F17.sf2.g1" src="x16.png" width="831"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(b)</span> </span><span class="ltx_text" style="font-size:90%;">Compute time and number of candidates found vs. the number of targets.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_break"></div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F17.sf3"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="564" id="F17.sf3.g1" src="x17.png" width="831"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(c)</span> </span><span class="ltx_text" style="font-size:90%;">Compute time and number of candidates found vs. the number of sources and with a constant number of samples per source.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F17.sf4"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="564" id="F17.sf4.g1" src="x18.png" width="831"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(d)</span> </span><span class="ltx_text" style="font-size:90%;">Compute time and number of candidates found vs. the total number of samples with a constant number of samples in total.</span></figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 17</span>: </span><span class="ltx_text" style="font-size:90%;">Computation time and number of candidates found as a function of the number of sources and targets. The experiments are conducted on an NVIDIA RTX 4090 GPU.</span></figcaption>
</figure>
<div class="ltx_para" id="SS1.SSS4.p2">
<p class="ltx_p">Moreover, the current method for handling multiple targets involves iterating over all targets during each <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop iteration. This approach may be optimized by selecting only targets near intersection points or the source, which will enhance scalability when dealing with a large number of targets. Figure <a class="ltx_ref" href="#F17.sf2" title="In Figure 17 ‣ 3.1.4 Potential Improvements ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">17(b)</span></a> illustrates this, showing the compute time of the candidate generator and the average number of candidates per target found as the number of targets varies. In this experiment, the built-in Sionna RT scene “simple street canyon” depicted in Figure <a class="ltx_ref" href="#F17.sf1" title="In Figure 17 ‣ 3.1.4 Potential Improvements ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">17(a)</span></a>, was used. Targets were sampled uniformly at random on a plane parallel to the ground at an elevation of 1.5 meters. The maximum depth <math alttext="L" class="ltx_Math" display="inline" id="SS1.SSS4.p2.m1"><mi>L</mi></math> was set to 5, diffuse reflections were disabled, and the number of samples <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS1.SSS4.p2.m2"><msub><mi>N</mi><mi>S</mi></msub></math> was set to <math alttext="10^{6}" class="ltx_Math" display="inline" id="SS1.SSS4.p2.m3"><msup><mn>10</mn><mn>6</mn></msup></math>. As observed, the compute time increases with the number of targets due to the iteration over all targets in each <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop iteration. However, the number of candidates per target remains stable, although with variations due to hash collisions. Note that, as discussed in Section <a class="ltx_ref" href="#SS2" title="3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.2</span></a>, most candidates do not result in valid paths.</p>
</div>
<div class="ltx_para" id="SS1.SSS4.p3">
<p class="ltx_p">Scaling with the number of sources presents its own set of challenges. When <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS1.SSS4.p3.m1"><msub><mi>N</mi><mi>S</mi></msub></math> samples are generated per source, the total number of samples produced by the candidate generator becomes <math alttext="N_{S}\cdot N_{O}" class="ltx_Math" display="inline" id="SS1.SSS4.p3.m2"><mrow><msub><mi>N</mi><mi>S</mi></msub><mo lspace="0.222em" rspace="0.222em">⋅</mo><msub><mi>N</mi><mi>O</mi></msub></mrow></math>, where <math alttext="N_{O}" class="ltx_Math" display="inline" id="SS1.SSS4.p3.m3"><msub><mi>N</mi><mi>O</mi></msub></math> denotes the number of sources. This results in increased computation time as the number of sources grows, as illustrated in Figure <a class="ltx_ref" href="#F17.sf3" title="In Figure 17 ‣ 3.1.4 Potential Improvements ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">17(c)</span></a>. However, the number of candidates per source remains stable. In this experiment, a single target is positioned at the center of the scene at an elevation of 1.5 meters, while sources are randomly sampled on a plane parallel to the ground at an elevation of 70 meters, above all buildings. Recall that variations in the number of candidates per source may occur due to collisions. For a comprehensive view, Figure <a class="ltx_ref" href="#F17.sf4" title="In Figure 17 ‣ 3.1.4 Potential Improvements ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">17(d)</span></a> presents results where the total number of samples is kept constant at <math alttext="10^{6}" class="ltx_Math" display="inline" id="SS1.SSS4.p3.m4"><msup><mn>10</mn><mn>6</mn></msup></math>, resulting in <math alttext="N_{S}=\left\lfloor\frac{10^{6}}{N_{O}}\right\rfloor" class="ltx_Math" display="inline" id="SS1.SSS4.p3.m5"><mrow><msub><mi>N</mi><mi>S</mi></msub><mo>=</mo><mrow><mo>⌊</mo><mfrac><msup><mn>10</mn><mn>6</mn></msup><msub><mi>N</mi><mi>O</mi></msub></mfrac><mo>⌋</mo></mrow></mrow></math> samples per source. In this scenario, the computation time increases at a much slower rate with the number of sources, but the number of candidates found per source decreases rapidly as the number of sources increases.</p>
</div>
</section>
</section>
<section class="ltx_subsection" id="SS2">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.2 </span>Image Method-based Candidate Processing</h2>
<div class="ltx_para" id="SS2.p1">
<p class="ltx_p">The image method processes path candidates to determine valid paths that are specular chains, or end with specular suffixes. Consider a candidate path</p>
<table class="ltx_equation ltx_eqn_table" id="E23">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="c_{n}^{(\ell)}=\left(\mathbf{s},\left(o_{n}^{(1)},m_{n}^{(1)},\chi_{n}^{(1)}%
\right),\cdots,\underbrace{\left(o_{n}^{(\ell_{d}+1)},m_{n}^{(\ell_{d}+1)},%
\chi_{n}^{(\ell_{d}+1)}\right),\cdots,\left(o_{n}^{(\ell)},m_{n}^{(\ell)},\chi%
_{n}^{(\ell)}\right),\mathbf{t}}_{\text{Specular suffix}}\right)" class="ltx_Math" display="block" id="E23.m1"><mrow><msubsup><mi>c</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mi>𝐬</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><munder><munder accentunder="true"><mrow><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mi>𝐭</mi></mrow><mo>⏟</mo></munder><mtext>Specular suffix</mtext></munder><mo>)</mo></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(23)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math alttext="\ell" class="ltx_Math" display="inline" id="SS2.p1.m1"><mi mathvariant="normal">ℓ</mi></math> denotes the path depth, <math alttext="\ell_{d}" class="ltx_Math" display="inline" id="SS2.p1.m2"><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub></math> is the specular suffix index defined as in (<a class="ltx_ref" href="S2.html#E10" title="In 2.4 Ray Tubes ‣ 2 Essential Concepts and Terminology ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a>), and <math alttext="\mathbf{t}" class="ltx_Math" display="inline" id="SS2.p1.m3"><mi>𝐭</mi></math> is the target of the path.
Recall that the sequence of interactions <math alttext="\boldsymbol{\chi}^{(\ell)}=\left(\chi_{n}^{(1)},\cdots,\chi_{n}^{(\ell)}\right)" class="ltx_Math" display="inline" id="SS2.p1.m4"><mrow><msup><mi>𝝌</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mrow><mo>(</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></math> was determined by the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>-based candidate generator.
For path candidates that end with a specular suffix but are not specular chains (i.e. <math alttext="\ell_{d}&gt;0" class="ltx_Math" display="inline" id="SS2.p1.m5"><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>&gt;</mo><mn>0</mn></mrow></math>), the image method processes only the specular suffix. In these cases, the vertex of the last diffuse reflection <math alttext="\mathbf{v}_{n}^{(\ell_{d})}" class="ltx_Math" display="inline" id="SS2.p1.m6"><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow></msubsup></math> serves as the source point for the image method calculations.
Since the processing algorithm is identical for both specular chains and specular suffixes, we treat them equivalently in the following discussion. For simplicity of notation, we will refer to both types as specular chains and assume <math alttext="\ell_{d}=0" class="ltx_Math" display="inline" id="SS2.p1.m7"><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo>=</mo><mn>0</mn></mrow></math> throughout the remainder of this section.</p>
</div>
<figure class="ltx_figure" id="F18">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F18.sf1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="580" id="F18.sf1.g1" src="x19.png" width="830"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(a)</span> </span><span class="ltx_text" style="font-size:90%;">Computing images of the source.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F18.sf2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="540" id="F18.sf2.g1" src="x20.png" width="830"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(b)</span> </span><span class="ltx_text" style="font-size:90%;">Backtracking the path.</span></figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 18</span>: </span><span class="ltx_text" style="font-size:90%;">Two-step process of the image method: (a) source image computation and (b) path backtracking. Shown in 2D for clarity.</span></figcaption>
</figure>
<div class="ltx_para" id="SS2.p2">
<p class="ltx_p">Figure <a class="ltx_ref" href="#F18" title="Figure 18 ‣ 3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">18</span></a> illustrates the image method process, which consists of two main steps. First, the method iteratively computes images of the source by reflecting it across each plane at which a specular reflection occurs.
Since refracted paths are modeled without angular deflection, incorporating refraction into the image method is straightforward: refraction events may simply be skipped when computing the source images, as they do not alter the ray’s direction.
Then, the algorithm backtracks from the target to determine the actual path vertices by intersecting lines between successive image sources.</p>
</div>
<div class="ltx_para" id="SS2.p3">
<p class="ltx_p">Formally, the image method iteratively computes images of the source <math alttext="\widetilde{\mathbf{s}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p3.m1"><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> for <math alttext="i=0,\dots,\ell" class="ltx_Math" display="inline" id="SS2.p3.m2"><mrow><mi>i</mi><mo>=</mo><mrow><mn>0</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mi mathvariant="normal">ℓ</mi></mrow></mrow></math>, starting from the original source <math alttext="\mathbf{s}" class="ltx_Math" display="inline" id="SS2.p3.m3"><mi>𝐬</mi></math>:</p>
<table class="ltx_equation ltx_eqn_table" id="E24">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\widetilde{\mathbf{s}}_{n}^{(i)}=\begin{cases}\mathbf{s}&amp;\text{if }i=0\\
\widetilde{\mathbf{s}}_{n}^{(i-1)}-2\left(\widetilde{\mathbf{s}}_{n}^{(i-1)}-%
\mathbf{p}_{n}^{(i)}\right)^{\mathsf{T}}\widehat{\mathbf{n}}_{n}^{(i)}&amp;\text{%
if }\chi_{n}^{(i)}={\cal R}\\
\widetilde{\mathbf{s}}_{n}^{(i-1)}&amp;\text{if }\chi_{n}^{(i)}={\cal T}\end{cases}" class="ltx_Math" display="block" id="E24.m1"><mrow><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mtr><mtd class="ltx_align_left" columnalign="left"><mi>𝐬</mi></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><mi>i</mi></mrow><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd class="ltx_align_left" columnalign="left"><mrow><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><mrow><mn>2</mn><mo>⁢</mo><msup><mrow><mo>(</mo><mrow><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>𝐩</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></mrow></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>=</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi></mrow></mtd></mtr><mtr><mtd class="ltx_align_left" columnalign="left"><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow></mtd></mtr></mtable></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(24)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">Here, <math alttext="\mathbf{p}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p3.m4"><msubsup><mi>𝐩</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> represents any point on the plane containing the primitive <math alttext="\left(o_{n}^{(i)},m_{n}^{(i)}\right)" class="ltx_Math" display="inline" id="SS2.p3.m5"><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></math>, and <math alttext="\widehat{\mathbf{n}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p3.m6"><msubsup><mover accent="true"><mi>𝐧</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> denotes the surface’s normal vector. For specular reflections (<math alttext="\chi_{n}^{(i)}={\cal R}" class="ltx_Math" display="inline" id="SS2.p3.m7"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">ℛ</mi></mrow></math>), the image is computed by reflecting the previous image across the surface plane, while for refractions (<math alttext="\chi_{n}^{(i)}={\cal T}" class="ltx_Math" display="inline" id="SS2.p3.m8"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow></math>), the image position remains unchanged.</p>
</div>
<div class="ltx_para" id="SS2.p4">
<p class="ltx_p">During backtracking, the algorithm traces rays iteratively from the target <math alttext="\mathbf{t}" class="ltx_Math" display="inline" id="SS2.p4.m1"><mi>𝐭</mi></math> back to the source <math alttext="\mathbf{s}" class="ltx_Math" display="inline" id="SS2.p4.m2"><mi>𝐬</mi></math> by intersecting lines between successive image points.
Specifically, a sequence of <math alttext="\ell" class="ltx_Math" display="inline" id="SS2.p4.m3"><mi mathvariant="normal">ℓ</mi></math> rays <math alttext="\left(\widetilde{\mathbf{t}}_{n}^{(i)},\widehat{\mathbf{d}}_{n}^{(i)}\right)" class="ltx_Math" display="inline" id="SS2.p4.m4"><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mover accent="true"><mi>𝐝</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></math>, <math alttext="i=\ell,\dots,0" class="ltx_Math" display="inline" id="SS2.p4.m5"><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mn>0</mn></mrow></mrow></math>, is traced according to</p>
<table class="ltx_equationgroup ltx_eqn_table" id="E25">
<tbody>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E25X">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\widetilde{\mathbf{t}}_{n}^{(i)}" class="ltx_Math" display="inline" id="E25X.m2"><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=\begin{cases}\mathbf{t}&amp;\text{if }i=\ell\\
\widetilde{\mathbf{v}}_{n}^{(i+1)}&amp;\text{if }1\leq i&lt;\ell\end{cases}" class="ltx_Math" display="inline" id="E25X.m3"><mrow><mi></mi><mo>=</mo><mrow><mo>{</mo><mtable columnspacing="5pt" rowspacing="0pt"><mtr><mtd class="ltx_align_left" columnalign="left"><mi>𝐭</mi></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><mi>i</mi></mrow><mo>=</mo><mi mathvariant="normal">ℓ</mi></mrow></mtd></mtr><mtr><mtd class="ltx_align_left" columnalign="left"><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><mn>1</mn></mrow><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi mathvariant="normal">ℓ</mi></mrow></mtd></mtr></mtable></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="3"><span class="ltx_tag ltx_tag_equationgroup ltx_align_right">(25)</span></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E25Xa">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\widehat{\mathbf{d}}_{n}^{(i)}" class="ltx_Math" display="inline" id="E25Xa.m2"><msubsup><mover accent="true"><mi>𝐝</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=\frac{\widetilde{\mathbf{s}}_{n}^{(i)}-\widetilde{\mathbf{t}}_{n%
}^{(i)}}{\left\lVert\widetilde{\mathbf{s}}_{n}^{(i)}-\widetilde{\mathbf{t}}_{n%
}^{(i)}\right\rVert_{2}}" class="ltx_Math" display="inline" id="E25Xa.m3"><mrow><mi></mi><mo>=</mo><mstyle displaystyle="true"><mfrac><mrow><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><msub><mrow><mo fence="true" rspace="0em">∥</mo><mrow><msubsup><mover accent="true"><mi>𝐬</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub></mfrac></mstyle></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E25Xb">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\widetilde{\mathbf{v}}_{n}^{(i)}" class="ltx_Math" display="inline" id="E25Xb.m2"><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=\texttt{intersection}\left(\left(\widetilde{\mathbf{t}}_{n}^{(i)%
},\widehat{\mathbf{d}}_{n}^{(i)}\right),\left(o_{n}^{(i)},m_{n}^{(i)}\right)%
\right),\text{only if }i&gt;0" class="ltx_Math" display="inline" id="E25Xb.m3"><mrow><mrow><mi></mi><mo>=</mo><mrow><mtext class="ltx_mathvariant_monospace">intersection</mtext><mo>⁢</mo><mrow><mo>(</mo><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mover accent="true"><mi>𝐝</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>,</mo><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mtext>only if </mtext><mo>⁢</mo><mi>i</mi></mrow><mo>&gt;</mo><mn>0</mn></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</tbody>
</table>
<p class="ltx_p">where <math alttext="\widetilde{\mathbf{v}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p4.m6"><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is the intersection point between the ray <math alttext="\left(\widetilde{\mathbf{t}}_{n}^{(i)},\widehat{\mathbf{d}}_{n}^{(i)}\right)" class="ltx_Math" display="inline" id="SS2.p4.m7"><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mover accent="true"><mi>𝐝</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></math> and the primitive <math alttext="\left(o_{n}^{(i)},m_{n}^{(i)}\right)" class="ltx_Math" display="inline" id="SS2.p4.m8"><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></math>, yielding the path vertex <math alttext="\widetilde{\mathbf{v}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p4.m9"><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> as shown in Figure <a class="ltx_ref" href="#F18.sf2" title="In Figure 18 ‣ 3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">18(b)</span></a>.
The path is considered valid only if two conditions are met: (i) each ray successfully intersects its corresponding primitive <math alttext="\left(o_{n}^{(i)},m_{n}^{(i)}\right)" class="ltx_Math" display="inline" id="SS2.p4.m10"><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>m</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></math>, and (ii) the line segment between <math alttext="\widetilde{\mathbf{t}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p4.m11"><msubsup><mover accent="true"><mi>𝐭</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> and <math alttext="\widetilde{\mathbf{v}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS2.p4.m12"><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math> is unobstructed by any other scene geometry. If either condition fails, the path will be discarded.
The case <math alttext="i=0" class="ltx_Math" display="inline" id="SS2.p4.m13"><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow></math> corresponds to the final segment of the path, which connects to the source <math alttext="\mathbf{s}" class="ltx_Math" display="inline" id="SS2.p4.m14"><mi>𝐬</mi></math>.
If the path is valid, then the returned path will be (<a class="ltx_ref" href="#E14" title="In Specular Reflection and Refraction ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">14</span></a>).</p>
</div>
<figure class="ltx_figure" id="F19">
<div class="ltx_flex_figure">
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F19.sf1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="337" id="F19.sf1.g1" src="figures/simple-street-canyon-cam-2.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(a)</span> </span><span class="ltx_text" style="font-size:90%;">Scene for this experiment. Red ball: source, green ball: target.</span></figcaption>
</figure>
</div>
<div class="ltx_flex_cell ltx_flex_size_2">
<figure class="ltx_figure ltx_figure_panel ltx_align_center" id="F19.sf2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="634" id="F19.sf2.g1" src="x21.png" width="831"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">(b)</span> </span><span class="ltx_text" style="font-size:90%;">Number of candidates and valid paths.</span></figcaption>
</figure>
</div>
</div>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 19</span>: </span><span class="ltx_text" style="font-size:90%;">The image method typically discards most candidates.</span></figcaption>
</figure>
<div class="ltx_para" id="SS2.p5">
<p class="ltx_p">Typically, most of the candidates are discarded by the image method. This is illustrated in Figure <a class="ltx_ref" href="#F19" title="Figure 19 ‣ 3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">19</span></a>, which shows the number of candidates discarded as a function of the path depth for a single source and target. The considered scene is shown in Figure <a class="ltx_ref" href="#F19.sf1" title="In Figure 19 ‣ 3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">19(a)</span></a>. The number of samples <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS2.p5.m1"><msub><mi>N</mi><mi>S</mi></msub></math> is <math alttext="10^{6}" class="ltx_Math" display="inline" id="SS2.p5.m2"><msup><mn>10</mn><mn>6</mn></msup></math> and diffuse reflection is disabled.
As seen in Figure <a class="ltx_ref" href="#F19.sf2" title="In Figure 19 ‣ 3.2 Image Method-based Candidate Processing ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">19(b)</span></a>, most of the candidates are discarded by the image method because only specular chains are generated by the candidate generator, and most of them do not result in valid paths.</p>
</div>
</section>
<section class="ltx_subsection" id="SS3">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.3 </span>Channel Coefficients, Delays, and Doppler Shifts Computation</h2>
<div class="ltx_para" id="SS3.p1">
<p class="ltx_p">The final step of the path solver computes complex-valued channel coefficients and real-valued delays for each valid path (see Figure <a class="ltx_ref" href="#F9" title="Figure 9 ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">9</span></a>).
For clarity, we will focus our discussion on a single valid path with index <math alttext="n" class="ltx_Math" display="inline" id="SS3.p1.m1"><mi>n</mi></math> and depth <math alttext="\ell" class="ltx_Math" display="inline" id="SS3.p1.m2"><mi mathvariant="normal">ℓ</mi></math>, though the same procedure applies to all valid paths computed by both the <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a>-based candidate generator and image method.
We denote the path vertices as <math alttext="\mathbf{v}_{n}^{(i)},\leavevmode\nobreak\ i=1,\dots,\ell" class="ltx_Math" display="inline" id="SS3.p1.m3"><mrow><mrow><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo rspace="0.667em">,</mo><mi>i</mi></mrow><mo>=</mo><mn>1</mn></mrow><mo>,</mo><mrow><mi mathvariant="normal">…</mi><mo>,</mo><mi mathvariant="normal">ℓ</mi></mrow></mrow></math>, which may correspond to vertices previously computed by the image method (denoted earlier as <math alttext="\widetilde{\mathbf{v}}_{n}^{(i)}" class="ltx_Math" display="inline" id="SS3.p1.m4"><msubsup><mover accent="true"><mi>𝐯</mi><mo>~</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></math>).
The directions of propagation between vertices are represented by unit vectors <math alttext="\widehat{\mathbf{k}}_{n}^{(i)},\leavevmode\nobreak\ i=0,\dots,\ell" class="ltx_Math" display="inline" id="SS3.p1.m5"><mrow><mrow><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo rspace="0.667em">,</mo><mi>i</mi></mrow><mo>=</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi mathvariant="normal">…</mi><mo>,</mo><mi mathvariant="normal">ℓ</mi></mrow></mrow></math>, defined as</p>
<table class="ltx_equation ltx_eqn_table" id="E26">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\widehat{\mathbf{k}}_{n}^{(i)}=\frac{\mathbf{v}_{n}^{(i+1)}-\mathbf{v}_{n}^{(i%
)}}{\left\lVert\mathbf{v}_{n}^{(i+1)}-\mathbf{v}_{n}^{(i)}\right\rVert_{2}},%
\qquad i=0,\dots,\ell" class="ltx_Math" display="block" id="E26.m1"><mrow><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mfrac><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><msub><mrow><mo fence="true" rspace="0em">∥</mo><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub></mfrac></mrow><mo rspace="2.167em">,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mn>0</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mi mathvariant="normal">ℓ</mi></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(26)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math alttext="\mathbf{v}_{n}^{(0)}=\mathbf{s}" class="ltx_Math" display="inline" id="SS3.p1.m6"><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi>𝐬</mi></mrow></math> is the source and <math alttext="\mathbf{v}_{n}^{(\ell+1)}=\mathbf{t}" class="ltx_Math" display="inline" id="SS3.p1.m7"><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi>𝐭</mi></mrow></math> is the target. Note that these propagation directions may differ from those used during the initial <a href="#glo.acronym.SBR"><span class="ltx_glossaryref" href="#glo.acronym.SBR" title="shooting and bouncing of rays">SBR</span></a> loop described in Section <a class="ltx_ref" href="#SS1" title="3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1</span></a> due to the refinement by the image method.</p>
</div>
<figure class="ltx_figure" id="F20"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="225" id="F20.g1" src="x22.png" width="498"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 20</span>: </span><span class="ltx_text" style="font-size:90%;">Due to the random sampling of interaction types, only some of the ray tubes that should reach the diffusely reflective surface (Scatterer 2) are traced. In this example, two out of four initial rays are transmitted when interacting with Scatterer 1, while the other two are reflected and reach the diffusely reflective surface.</span></figcaption>
</figure>
<section class="ltx_paragraph" id="SS3.SSS0.Px1">
<h4 class="ltx_title ltx_title_paragraph">Ensuring Energy Conservation</h4>
<div class="ltx_para" id="SS3.SSS0.Px1.p1">
<p class="ltx_p">As explained in Section <a class="ltx_ref" href="#SS1.SSS2" title="3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">3.1.2</span></a>, at each interaction point, an interaction type is randomly chosen based on the probability distribution <math alttext="{\cal Q}" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p1.m1"><mi class="ltx_font_mathcaligraphic">𝒬</mi></math> (<a class="ltx_ref" href="#E17" title="In 3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">17</span></a>). Initially, the energy emitted by the source is distributed across <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p1.m2"><msub><mi>N</mi><mi>S</mi></msub></math> samples according to the transmit antenna pattern (see Section <a class="ltx_ref" href="A1.html#SS3" title="A.3 Far Field of a Transmitting Antenna ‣ Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">A.3</span></a>). Since only one interaction type is selected at each interaction point, ray tubes that do not match the chosen interaction type are discarded, as illustrated in Figure <a class="ltx_ref" href="#F20" title="Figure 20 ‣ 3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">20</span></a>. The remaining ray tubes must therefore compensate for the discarded ones to maintain energy conservation. Specular reflection and refraction on planar surfaces only change the direction of the ray tube’s propagation. Given that there is a finite number of specular chains with a specific depth, the channel gain (<a class="ltx_ref" href="S1.html#E5" title="In 1 Introduction ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">5</span></a>) observed at the target due to specular chains is accurate if all specular chains are identified by the path solver, which is assumed to be the case. This assumption will be reasonable if the number of samples <math alttext="N_{S}" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p1.m3"><msub><mi>N</mi><mi>S</mi></msub></math> is sufficiently large.</p>
</div>
<div class="ltx_para" id="SS3.SSS0.Px1.p2">
<p class="ltx_p">In the context of diffuse reflections, an incident ray tube scatters an amount of energy that is determined by its footprint on the diffusely reflective surface (see Section <a class="ltx_ref" href="A1.html#SS8" title="A.8 Diffuse Reflection ‣ Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">A.8</span></a>). Due to the random sampling of interaction types, only a portion of the ray tubes that should reach a diffusely reflective surface are actually traced (see Figure <a class="ltx_ref" href="#F20" title="Figure 20 ‣ 3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">20</span></a>), which requires compensating for the untraced ones. For a given path <math alttext="p^{(\ell)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p2.m1"><msup><mi>p</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msup></math> that includes a diffuse reflection and has a specular suffix index <math alttext="\ell_{d}" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p2.m2"><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub></math> (<a class="ltx_ref" href="S2.html#E10" title="In 2.4 Ray Tubes ‣ 2 Essential Concepts and Terminology ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">10</span></a>), we denote by <math alttext="\Pr\left(\boldsymbol{\chi}_{n}^{(\ell_{d})}\right)=\prod_{\ell^{\prime}=1}^{%
\ell_{d}}q\left(\chi_{n}^{(\ell^{\prime})}\right)" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p2.m3"><mrow><mrow><mi>Pr</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝝌</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow><mo rspace="0.111em">=</mo><mrow><msubsup><mo>∏</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>=</mo><mn>1</mn></mrow><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub></msubsup><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mrow></mrow></math> the probability of sampling the prefix leading to the last diffuse reflection point, where <math alttext="q\left(\cdot\right)" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p2.m4"><mrow><mi>q</mi><mo>⁢</mo><mrow><mo>(</mo><mo lspace="0em" rspace="0em">⋅</mo><mo>)</mo></mrow></mrow></math> is defined in (<a class="ltx_ref" href="#E17" title="In 3.1.2 Sampling Interaction Types ‣ 3.1 Generating Candidates by Shooting and Bouncing of Rays (SBR) ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">17</span></a>). Consequently, on average, only a fraction <math alttext="\Pr\left(\boldsymbol{\chi}_{n}^{(\ell_{d})}\right)" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p2.m5"><mrow><mi>Pr</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝝌</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></math> of the ray tubes that should reach the diffusely reflective surface are actually traced. To account for this, the electric field is scaled by <math alttext="\nicefrac{{1}}{{\sqrt{\Pr\left(\boldsymbol{\chi}_{n}^{(\ell_{d})}\right)}}}" class="ltx_Math" display="inline" id="SS3.SSS0.Px1.p2.m6"><mrow><mpadded voffset="0.3em"><mn mathsize="70%">1</mn></mpadded><mpadded lspace="-0.1em" width="-0.15em"><mo stretchy="true" symmetric="true">/</mo></mpadded><msqrt><mrow><mi mathsize="70%">Pr</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi mathsize="70%">𝝌</mi><mi mathsize="71%">n</mi><mrow><mo maxsize="71%" minsize="71%">(</mo><msub><mi mathsize="71%" mathvariant="normal">ℓ</mi><mi>d</mi></msub><mo maxsize="71%" minsize="71%">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></msqrt></mrow></math> at the point of diffuse reflection.</p>
</div>
<figure class="ltx_float ltx_float_algorithm ltx_framed ltx_framed_top" id="alg2">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold">Algorithm 2</span> </span> Electric field computation</figcaption>
<div class="ltx_listing ltx_listing">
<div class="ltx_listingline" id="alg2.l1">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">1:</span></span>
<math alttext="\mathbf{E}_{n}^{(0)}\leftarrow\textsc{tx\_pattern}(\widehat{\mathbf{k}}^{(0)}_%
{n})" class="ltx_Math" display="inline" id="alg2.l1.m1"><mrow><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">tx_pattern</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">)</mo></mrow></mrow></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg2.l1.m2"><mo>▷</mo></math> Electric field vector
</span>
</div>
<div class="ltx_listingline" id="alg2.l2">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">2:</span></span>
<math alttext="\tau_{n}^{(0)}\leftarrow 0" class="ltx_Math" display="inline" id="alg2.l2.m1"><mrow><msubsup><mi>τ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>0</mn></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg2.l2.m2"><mo>▷</mo></math> Cumulative delay
</span>
</div>
<div class="ltx_listingline" id="alg2.l3">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">3:</span></span>
<math alttext="r_{n}^{(0)}\leftarrow 0" class="ltx_Math" display="inline" id="alg2.l3.m1"><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>0</mn></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg2.l3.m2"><mo>▷</mo></math> Cumulative ray tube length
</span>
</div>
<div class="ltx_listingline" id="alg2.l4">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">4:</span></span>
<math alttext="\gamma_{n}^{(0)}\leftarrow 1" class="ltx_Math" display="inline" id="alg2.l4.m1"><mrow><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>1</mn></mrow></math> <span class="ltx_text" style="float:right;"><math alttext="\triangleright" class="ltx_Math" display="inline" id="alg2.l4.m2"><mo>▷</mo></math> Cumulative path probability
</span>
</div>
<div class="ltx_listingline" id="alg2.l5">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">5:</span></span>
<math alttext="\ell^{\prime}\leftarrow 1" class="ltx_Math" display="inline" id="alg2.l5.m1"><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">←</mo><mn>1</mn></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l6">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">6:</span></span>
<span class="ltx_text ltx_font_bold">while</span> <span class="ltx_text ltx_font_bold">not</span> &lt;Stop condition&gt; <span class="ltx_text ltx_font_bold">do</span>
</div>
<div class="ltx_listingline" id="alg2.l7">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">7:</span></span>
                
                
                   <math alttext="\mathbf{T}_{n}^{(\ell^{\prime})}\leftarrow\textsc{Evaluate\_Material}(o_{n}^{(%
\ell^{\prime})},\chi_{n}^{(\ell^{\prime})},\mathbf{E}_{n}^{(\ell^{\prime}-1)},%
\widehat{\mathbf{k}}_{n}^{(\ell^{\prime}-1)},\widehat{\mathbf{k}}_{n}^{(\ell^{%
\prime})})" class="ltx_Math" display="inline" id="alg2.l7.m1"><mrow><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">Evaluate_Material</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>,</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l8">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">8:</span></span>
                
                
                   <math alttext="\mathbf{E}_{n}^{(\ell^{\prime})}\leftarrow\mathbf{T}_{n}^{(\ell^{\prime})}%
\mathbf{E}_{n}^{(\ell^{\prime}-1)}" class="ltx_Math" display="inline" id="alg2.l8.m1"><mrow><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>⁢</mo><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l9">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">9:</span></span>
                
                
                   <math alttext="\gamma_{n}^{(\ell^{\prime})}\leftarrow\gamma_{n}^{(\ell^{\prime}-1)}\cdot q_{n%
}^{(\ell^{\prime})}\left(\chi_{n}^{(\ell^{\prime})}\right)" class="ltx_Math" display="inline" id="alg2.l9.m1"><mrow><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><mrow><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo lspace="0.222em" rspace="0.222em">⋅</mo><msubsup><mi>q</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>⁢</mo><mrow><mo>(</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l10">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">10:</span></span>
                
                
                   <span class="ltx_text ltx_font_bold">if</span> <math alttext="\chi_{n}^{(\ell^{\prime})}={\cal S}" class="ltx_Math" display="inline" id="alg2.l10.m1"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒮</mi></mrow></math> <span class="ltx_text ltx_font_bold">then</span>
</div>
<div class="ltx_listingline" id="alg2.l11">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">11:</span></span>
                
                
                       <math alttext="\mathbf{E}_{n}^{(\ell^{\prime})}\leftarrow\frac{\mathbf{E}_{n}^{(\ell^{\prime}%
)}}{\sqrt{\gamma_{n}^{(\ell^{\prime})}}}" class="ltx_Math" display="inline" id="alg2.l11.m1"><mrow><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mfrac><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><msqrt><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></msqrt></mfrac></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l12">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">12:</span></span>
                
                
                       <math alttext="\gamma_{n}^{(\ell^{\prime})}\leftarrow 1" class="ltx_Math" display="inline" id="alg2.l12.m1"><mrow><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>1</mn></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l13">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">13:</span></span>
                
                
                       <math alttext="r_{n}^{(\ell^{\prime}-1)}\leftarrow 0" class="ltx_Math" display="inline" id="alg2.l13.m1"><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>0</mn></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l14">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">14:</span></span>
                
                
                   <span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">if</span>
</div>
<div class="ltx_listingline" id="alg2.l15">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">15:</span></span>
                
                
                   <math alttext="r_{n}^{(\ell^{\prime})}\leftarrow r_{n}^{(\ell^{\prime}-1)}+\left\lVert\mathbf%
{v}_{n}^{(\ell^{\prime})}-\mathbf{v}_{n}^{(\ell^{\prime}-1)}\right\rVert_{2}" class="ltx_Math" display="inline" id="alg2.l15.m1"><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><msub><mrow><mo fence="true" lspace="0em" rspace="0em">∥</mo><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l16">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">16:</span></span>
                
                
                   <math alttext="\tau_{n}^{(\ell^{\prime})}\leftarrow\tau_{n}^{(\ell^{\prime}-1)}+\frac{\left%
\lVert\mathbf{v}_{n}^{(\ell^{\prime})}-\mathbf{v}_{n}^{(\ell^{\prime}-1)}%
\right\rVert_{2}}{c}" class="ltx_Math" display="inline" id="alg2.l16.m1"><mrow><msubsup><mi>τ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><msubsup><mi>τ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mfrac><msub><mrow><mo fence="true" rspace="0em">∥</mo><mrow><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub><mi>c</mi></mfrac></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l17">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">17:</span></span>
                
                
                   <math alttext="\ell^{\prime}\leftarrow\ell^{\prime}+1" class="ltx_Math" display="inline" id="alg2.l17.m1"><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">←</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>+</mo><mn>1</mn></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l18">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">18:</span></span>
<span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">while</span>
</div>
<div class="ltx_listingline" id="alg2.l19">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">19:</span></span>
<math alttext="\tau_{n}\leftarrow\tau_{n}^{(\ell)}+\frac{\left\lVert\mathbf{t}-\mathbf{v}_{n}%
^{(\ell)}\right\rVert_{2}}{c}" class="ltx_Math" display="inline" id="alg2.l19.m1"><mrow><msub><mi>τ</mi><mi>n</mi></msub><mo stretchy="false">←</mo><mrow><msubsup><mi>τ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mfrac><msub><mrow><mo fence="true" rspace="0em">∥</mo><mrow><mi>𝐭</mi><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub><mi>c</mi></mfrac></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l20">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">20:</span></span>
<span class="ltx_text ltx_font_bold">if</span> <math alttext="\chi_{n}^{(\ell)}={\cal S}" class="ltx_Math" display="inline" id="alg2.l20.m1"><mrow><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mi class="ltx_font_mathcaligraphic">𝒮</mi></mrow></math> <span class="ltx_text ltx_font_bold">then</span>
</div>
<div class="ltx_listingline" id="alg2.l21">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">21:</span></span>
                
                
                   <math alttext="r_{n}^{(\ell-1)}\leftarrow 0" class="ltx_Math" display="inline" id="alg2.l21.m1"><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mn>0</mn></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l22">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">22:</span></span>
<span class="ltx_text ltx_font_bold">end</span> <span class="ltx_text ltx_font_bold">if</span>
</div>
<div class="ltx_listingline" id="alg2.l23">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">23:</span></span>
<math alttext="r_{n}^{(\ell)}\leftarrow r_{n}^{(\ell-1)}+\left\lVert\mathbf{t}-\mathbf{v}_{n}%
^{(\ell)}\right\rVert_{2}" class="ltx_Math" display="inline" id="alg2.l23.m1"><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">ℓ</mi><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><msub><mrow><mo fence="true" lspace="0em" rspace="0em">∥</mo><mrow><mi>𝐭</mi><mo>−</mo><msubsup><mi>𝐯</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo fence="true" lspace="0em" stretchy="true">∥</mo></mrow><mn>2</mn></msub></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l24">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">24:</span></span>
<math alttext="\mathbf{E}_{n}^{(r)}\leftarrow\textsc{rx\_pattern}(-\widehat{\mathbf{k}}_{n}^{%
(\ell)})" class="ltx_Math" display="inline" id="alg2.l24.m1"><mrow><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">←</mo><mrow><mtext class="ltx_font_smallcaps">rx_pattern</mtext><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mo>−</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l25">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">25:</span></span>
<math alttext="a_{n}\leftarrow\frac{\lambda}{4\pi r_{n}^{(\ell)}}\left(\left(\mathbf{E}_{n}^{%
(\ell)}\right)^{\mathsf{T}}\mathbf{E}_{n}^{(r)}\right)" class="ltx_Math" display="inline" id="alg2.l25.m1"><mrow><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">←</mo><mrow><mfrac><mi>λ</mi><mrow><mn>4</mn><mo>⁢</mo><mi>π</mi><mo>⁢</mo><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></mfrac><mo>⁢</mo><mrow><mo>(</mo><mrow><msup><mrow><mo>(</mo><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>)</mo></mrow></mrow></mrow></math>
</div>
<div class="ltx_listingline" id="alg2.l26">
<span class="ltx_tag ltx_tag_listingline"><span class="ltx_text" style="font-size:80%;">26:</span></span>
<span class="ltx_text ltx_font_bold">return</span> <math alttext="a_{n},\leavevmode\nobreak\ \tau_{n}" class="ltx_Math" display="inline" id="alg2.l26.m1"><mrow><msub><mi>a</mi><mi>n</mi></msub><mo rspace="0.667em">,</mo><msub><mi>τ</mi><mi>n</mi></msub></mrow></math>
</div>
</div>
</figure>
</section>
<section class="ltx_paragraph" id="SS3.SSS0.Px2">
<h4 class="ltx_title ltx_title_paragraph">Path Coefficient and Delay Computation</h4>
<div class="ltx_para" id="SS3.SSS0.Px2.p1">
<p class="ltx_p">Algorithm <a class="ltx_ref" href="#alg2" title="Algorithm 2 ‣ Ensuring Energy Conservation ‣ 3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">2</span></a> details the computation of the electric field propagation along a valid path, leveraging the <a href="#glo.acronym.EM"><span class="ltx_glossaryref" href="#glo.acronym.EM" title="electromagnetic">EM</span></a> background presented in Appendix <a class="ltx_ref" href="A1.html" title="Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">A</span></a>.
The algorithm begins by initializing the electric field vector <math alttext="\mathbf{E}_{n}^{(0)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m1"><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> using the transmit antenna’s pattern evaluated in the initial propagation direction <math alttext="\widehat{\mathbf{k}}_{n}^{(0)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m2"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math>.
Note that the path solver supports dual polarization by considering two independent electric field vectors for each traced path.
The variable <math alttext="\tau_{n}^{(0)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m3"><msubsup><mi>τ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> tracks the cumulative path delay and is initialized to zero, and the variable <math alttext="r_{n}^{(0)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m4"><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> tracks the ray tube length and is also initialized to zero.
The variable <math alttext="\gamma_{n}^{(0)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m5"><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> is used to track the cumulative path probability and is initialized to one (see previous paragraph).
For each interaction point along the path, the electric field is updated by a transformation matrix <math alttext="\mathbf{T}_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m6"><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math>, which is computed based on the intersected object <math alttext="o_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m7"><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math>, interaction type <math alttext="\chi_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m8"><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math>, incident field <math alttext="\mathbf{E}_{n}^{(\ell^{\prime}-1)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m9"><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></math>, and both incident <math alttext="\widehat{\mathbf{k}}_{n}^{(\ell^{\prime}-1)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m10"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></math> and scattered <math alttext="\widehat{\mathbf{k}}_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m11"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> directions.
The cumulative path probability <math alttext="\gamma_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m12"><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> is updated by multiplying it with the interaction probability <math alttext="q_{n}^{(\ell^{\prime})}\left(\chi_{n}^{(\ell^{\prime})}\right)" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m13"><mrow><msubsup><mi>q</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>⁢</mo><mrow><mo>(</mo><msubsup><mi>χ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></math>.
When a diffuse reflection occurs, the electric field is normalized by <math alttext="\sqrt{\gamma_{n}^{(\ell^{\prime})}}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m14"><msqrt><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></msqrt></math> to maintain energy conservation and <math alttext="\gamma_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m15"><msubsup><mi>γ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> is reset to one and the ray tube length <math alttext="r_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m16"><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> to zero.
The ray tube length <math alttext="r_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m17"><msubsup><mi>r</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> is updated by adding the distance between the current and previous vertex, and the delay <math alttext="\tau_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m18"><msubsup><mi>τ</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> is updated by adding the time it takes to travel that distance, where <math alttext="c" class="ltx_Math" display="inline" id="SS3.SSS0.Px2.p1.m19"><mi>c</mi></math> is the speed of light.
After replaying all interactions, the final path segment to the target is incorporated into the delay and ray tube length.
Finally, the receive antenna pattern is evaluated for the incoming direction, and the channel coefficient is computed following Section <a class="ltx_ref" href="A1.html#SS6" title="A.6 Frequency and Impulse Response ‣ Appendix A Primer on Electromagnetism ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">A.6</span></a>.</p>
</div>
</section>
<section class="ltx_paragraph" id="SS3.SSS0.Px3">
<h4 class="ltx_title ltx_title_paragraph">Remark</h4>
<div class="ltx_para" id="SS3.SSS0.Px3.p1">
<p class="ltx_p">The transformation matrices <math alttext="\mathbf{T}_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px3.p1.m1"><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> and the electric field vectors <math alttext="\mathbf{E}_{n}^{(\ell^{\prime})}" class="ltx_Math" display="inline" id="SS3.SSS0.Px3.p1.m2"><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup></math> are complex-valued, but are implemented using their real-valued representations defined as</p>
<table class="ltx_equation ltx_eqn_table" id="E27">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\begin{bmatrix}\Re\left(\mathbf{T}_{n}^{(\ell^{\prime})}\right)&amp;-\Im\left(%
\mathbf{T}_{n}^{(\ell^{\prime})}\right)\\
\Im\left(\mathbf{T}_{n}^{(\ell^{\prime})}\right)&amp;\Re\left(\mathbf{T}_{n}^{(%
\ell^{\prime})}\right)\end{bmatrix}" class="ltx_Math" display="block" id="E27.m1"><mrow><mo>[</mo><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mtr><mtd><mrow><mi mathvariant="normal">ℜ</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mtd><mtd><mrow><mo rspace="0.167em">−</mo><mrow><mi mathvariant="normal">ℑ</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="normal">ℑ</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mtd><mtd><mrow><mi mathvariant="normal">ℜ</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝐓</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mtd></mtr></mtable><mo>]</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(27)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">for matrices and</p>
<table class="ltx_equation ltx_eqn_table" id="E28">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\begin{bmatrix}\Re\left(\mathbf{E}_{n}^{(\ell^{\prime})}\right)\\
\Im\left(\mathbf{E}_{n}^{(\ell^{\prime})}\right)\end{bmatrix}" class="ltx_Math" display="block" id="E28.m1"><mrow><mo>[</mo><mtable displaystyle="true" rowspacing="0pt"><mtr><mtd><mrow><mi mathvariant="normal">ℜ</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="normal">ℑ</mi><mo>⁡</mo><mrow><mo>(</mo><msubsup><mi>𝐄</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow></mrow></mtd></mtr></mtable><mo>]</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(28)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">for vectors, where <math alttext="\Re{\left(\cdot\right)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px3.p1.m3"><mrow><mi mathvariant="normal">ℜ</mi><mo>⁡</mo><mrow><mo>(</mo><mo lspace="0em" rspace="0em">⋅</mo><mo>)</mo></mrow></mrow></math> and <math alttext="\Im{\left(\cdot\right)}" class="ltx_Math" display="inline" id="SS3.SSS0.Px3.p1.m4"><mrow><mi mathvariant="normal">ℑ</mi><mo>⁡</mo><mrow><mo>(</mo><mo lspace="0em" rspace="0em">⋅</mo><mo>)</mo></mrow></mrow></math> denote the real and imaginary parts, respectively.</p>
</div>
</section>
<section class="ltx_subsubsection" id="SS3.SSS1">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.3.1 </span>Handling Multiple Antennas at the Transmitter and Receiver</h3>
<div class="ltx_para" id="SS3.SSS1.p1">
<p class="ltx_p">As explained in the Introduction (Section <a class="ltx_ref" href="S1.html" title="1 Introduction ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">1</span></a>), Sionna RT supports antenna arrays of any size at both the transmitter and receiver, utilizing either synthetic or non-synthetic arrays. In the case of non-synthetic arrays, each transmit antenna is treated as a source and each receive antenna as a target, meaning paths are traced from every transmit antenna, and the solver calculates paths for each transmit-receive antenna pair. For synthetic arrays, paths originate from a single “virtual” source at the center of the transmitter array, and a single “virtual” target is considered at the center of every receiver array. Channel coefficients are then computed by applying phase shifts synthetically. This method allows for efficient scaling with the number of antennas, but it is an approximation that is valid only when the transmitter and receiver array sizes are small relative to the distance from the radio devices to each other and to the scatterers. Formally, for synthetic arrays, the channel matrix for the <math alttext="n" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m1"><mi>n</mi></math>-th path is expressed as:</p>
<table class="ltx_equation ltx_eqn_table" id="E29">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\mathbf{H}_{\text{array},n}=a_{n}\mathbf{u}_{A}^{\text{rx}}\left(\mathbf{u}_{A%
}^{\text{tx}}\right)^{\mathsf{T}}" class="ltx_Math" display="block" id="E29.m1"><mrow><msub><mi>𝐇</mi><mrow><mtext>array</mtext><mo>,</mo><mi>n</mi></mrow></msub><mo>=</mo><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>⁢</mo><msubsup><mi>𝐮</mi><mi>A</mi><mtext>rx</mtext></msubsup><mo>⁢</mo><msup><mrow><mo>(</mo><msubsup><mi>𝐮</mi><mi>A</mi><mtext>tx</mtext></msubsup><mo>)</mo></mrow><mi>𝖳</mi></msup></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(29)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math alttext="a_{n}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m2"><msub><mi>a</mi><mi>n</mi></msub></math> is the channel coefficient for the <math alttext="n" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m3"><mi>n</mi></math>-th path, calculated using Algorithm <a class="ltx_ref" href="#alg2" title="Algorithm 2 ‣ Ensuring Energy Conservation ‣ 3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">2</span></a>. The array response vectors for the transmit (<math alttext="\mathbf{u}_{A}^{\text{tx}}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m4"><msubsup><mi>𝐮</mi><mi>A</mi><mtext>tx</mtext></msubsup></math>) and receive (<math alttext="\mathbf{u}_{A}^{\text{rx}}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m5"><msubsup><mi>𝐮</mi><mi>A</mi><mtext>rx</mtext></msubsup></math>) antenna arrays are defined as:</p>
<table class="ltx_equationgroup ltx_eqn_table" id="E30">
<tbody>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E30X">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\mathbf{u}_{A}^{\text{tx}}" class="ltx_Math" display="inline" id="E30X.m2"><msubsup><mi>𝐮</mi><mi>A</mi><mtext>tx</mtext></msubsup></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=\left[e^{j\frac{2\pi}{\lambda}\left(\widehat{\mathbf{k}}_{n}^{(0%
)}\right)^{\mathsf{T}}\mathbf{d}_{1}^{\text{tx}}},\cdots,e^{j\frac{2\pi}{%
\lambda}\left(\widehat{\mathbf{k}}_{n}^{(0)}\right)^{\mathsf{T}}\mathbf{d}_{N_%
{A}^{\text{tx}}}^{\text{tx}}}\right]^{\mathsf{T}}," class="ltx_Math" display="inline" id="E30X.m3"><mrow><mrow><mi></mi><mo>=</mo><msup><mrow><mo>[</mo><msup><mi>e</mi><mrow><mi>j</mi><mo>⁢</mo><mfrac><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow><mi>λ</mi></mfrac><mo>⁢</mo><msup><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mi>𝐝</mi><mn>1</mn><mtext>tx</mtext></msubsup></mrow></msup><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><msup><mi>e</mi><mrow><mi>j</mi><mo>⁢</mo><mfrac><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow><mi>λ</mi></mfrac><mo>⁢</mo><msup><mrow><mo>(</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mi>𝐝</mi><msubsup><mi>N</mi><mi>A</mi><mtext>tx</mtext></msubsup><mtext>tx</mtext></msubsup></mrow></msup><mo>]</mo></mrow><mi>𝖳</mi></msup></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="2"><span class="ltx_tag ltx_tag_equationgroup ltx_align_right">(30)</span></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E30Xa">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math alttext="\displaystyle\mathbf{u}_{A}^{\text{rx}}" class="ltx_Math" display="inline" id="E30Xa.m2"><msubsup><mi>𝐮</mi><mi>A</mi><mtext>rx</mtext></msubsup></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math alttext="\displaystyle=\left[e^{j\frac{2\pi}{\lambda}\left(-\widehat{\mathbf{k}}_{n}^{(%
\ell)}\right)^{\mathsf{T}}\mathbf{d}_{1}^{\text{rx}}},\cdots,e^{j\frac{2\pi}{%
\lambda}\left(-\widehat{\mathbf{k}}_{n}^{(\ell)}\right)^{\mathsf{T}}\mathbf{d}%
_{N_{A}^{\text{rx}}}^{\text{rx}}}\right]^{\mathsf{T}}." class="ltx_Math" display="inline" id="E30Xa.m3"><mrow><mrow><mi></mi><mo>=</mo><msup><mrow><mo>[</mo><msup><mi>e</mi><mrow><mi>j</mi><mo>⁢</mo><mfrac><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow><mi>λ</mi></mfrac><mo>⁢</mo><msup><mrow><mo>(</mo><mrow><mo>−</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mi>𝐝</mi><mn>1</mn><mtext>rx</mtext></msubsup></mrow></msup><mo>,</mo><mi mathvariant="normal">⋯</mi><mo>,</mo><msup><mi>e</mi><mrow><mi>j</mi><mo>⁢</mo><mfrac><mrow><mn>2</mn><mo>⁢</mo><mi>π</mi></mrow><mi>λ</mi></mfrac><mo>⁢</mo><msup><mrow><mo>(</mo><mrow><mo>−</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mi>𝐝</mi><msubsup><mi>N</mi><mi>A</mi><mtext>rx</mtext></msubsup><mtext>rx</mtext></msubsup></mrow></msup><mo>]</mo></mrow><mi>𝖳</mi></msup></mrow><mo lspace="0em">.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</tbody>
</table>
<p class="ltx_p">Here, <math alttext="\widehat{\mathbf{k}}_{n}^{(0)}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m6"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></math> (<math alttext="\widehat{\mathbf{k}}_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m7"><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math>) represents the departure (arrival) direction of the <math alttext="n" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m8"><mi>n</mi></math>-th path, <math alttext="N_{A}^{\text{tx}}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m9"><msubsup><mi>N</mi><mi>A</mi><mtext>tx</mtext></msubsup></math> (<math alttext="N_{A}^{\text{rx}}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m10"><msubsup><mi>N</mi><mi>A</mi><mtext>rx</mtext></msubsup></math>) denotes the number of antennas in the transmit (receive) array, and <math alttext="\mathbf{d}_{i}^{\text{tx}}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m11"><msubsup><mi>𝐝</mi><mi>i</mi><mtext>tx</mtext></msubsup></math> (<math alttext="\mathbf{d}_{i}^{\text{rx}}" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m12"><msubsup><mi>𝐝</mi><mi>i</mi><mtext>rx</mtext></msubsup></math>) indicates the relative position of the <math alttext="i" class="ltx_Math" display="inline" id="SS3.SSS1.p1.m13"><mi>i</mi></math>-th antenna element to the virtual source (target) in the transmit (receive) array.</p>
</div>
</section>
<section class="ltx_subsubsection" id="SS3.SSS2">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.3.2 </span>Doppler Shifts</h3>
<div class="ltx_para" id="SS3.SSS2.p1">
<p class="ltx_p">The impact of moving scene objects on the paths can be simulated in two ways.
The first approach involves moving objects in small incremental steps along their trajectories and recomputing the propagation paths at each step.
While this method provides the highest accuracy, it is computationally expensive.
However, when trajectory lengths are small (not exceeding a few wavelengths), a more efficient approach may be used.
In this alternative method, we assign a velocity vector <math alttext="\boldsymbol{\varv}\left(o\right)\in\mathbb{R}^{3}" class="ltx_Math" display="inline" id="SS3.SSS2.p1.m1"><mrow><mrow><mi>𝒗</mi><mo>⁢</mo><mrow><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mrow><mo>∈</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math> to each object <math alttext="o" class="ltx_Math" display="inline" id="SS3.SSS2.p1.m2"><mi>o</mi></math> and compute the time evolution by accumulating Doppler shifts along the propagation paths.</p>
</div>
<figure class="ltx_figure" id="F21"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="201" id="F21.g1" src="x23.png" width="498"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text" style="font-size:90%;">Figure 21</span>: </span><span class="ltx_text" style="font-size:90%;">Each object as well as the source and target has an associated velocity vector that contributes to the total Doppler shift. Shown in 2D for clarity.</span></figcaption>
</figure>
<div class="ltx_para" id="SS3.SSS2.p2">
<p class="ltx_p">Figure <a class="ltx_ref" href="#F21" title="Figure 21 ‣ 3.3.2 Doppler Shifts ‣ 3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">21</span></a> illustrates this approach.
When replaying the valid paths using Algorithm <a class="ltx_ref" href="#alg2" title="Algorithm 2 ‣ Ensuring Energy Conservation ‣ 3.3 Channel Coefficients, Delays, and Doppler Shifts Computation ‣ 3 Path Solver ‣ Sionna RT: Technical Report"><span class="ltx_text ltx_ref_tag">2</span></a>, the Doppler shift for each path <math alttext="n" class="ltx_Math" display="inline" id="SS3.SSS2.p2.m1"><mi>n</mi></math> is computed by accumulating the contributions from individual objects:</p>
<table class="ltx_equation ltx_eqn_table" id="E31">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\nu_{n}^{(\ell^{\prime})}=\begin{cases}0&amp;\text{if }\ell^{\prime}=0\\
\nu_{n}^{(\ell^{\prime}-1)}+\frac{\boldsymbol{\varv}\left(o_{n}^{(\ell^{\prime%
})}\right)^{\mathsf{T}}\left(\widehat{\mathbf{k}}_{n}^{(\ell^{\prime})}-%
\widehat{\mathbf{k}}_{n}^{(\ell^{\prime}-1)}\right)}{\lambda}&amp;\text{if }1\leq%
\ell^{\prime}&lt;\ell\\
\end{cases}" class="ltx_Math" display="block" id="E31.m1"><mrow><msubsup><mi>ν</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mtr><mtd class="ltx_align_left" columnalign="left"><mn>0</mn></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup></mrow><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd class="ltx_align_left" columnalign="left"><mrow><msubsup><mi>ν</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mstyle displaystyle="false"><mfrac><mrow><mi>𝒗</mi><mo>⁢</mo><msup><mrow><mo>(</mo><msubsup><mi>o</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><mrow><mo>(</mo><mrow><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></msubsup><mo>−</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mrow><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>−</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></msubsup></mrow><mo>)</mo></mrow></mrow><mi>λ</mi></mfrac></mstyle></mrow></mtd><mtd class="ltx_align_left" columnalign="left"><mrow><mrow><mtext>if </mtext><mo>⁢</mo><mn>1</mn></mrow><mo>≤</mo><msup><mi mathvariant="normal">ℓ</mi><mo>′</mo></msup><mo>&lt;</mo><mi mathvariant="normal">ℓ</mi></mrow></mtd></mtr></mtable></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(31)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math alttext="\lambda" class="ltx_Math" display="inline" id="SS3.SSS2.p2.m2"><mi>λ</mi></math> is the wavelength. This results in the total Doppler shift <math alttext="\nu_{n}^{(\ell)}" class="ltx_Math" display="inline" id="SS3.SSS2.p2.m3"><msubsup><mi>ν</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></math> caused by object movements along the path. The final Doppler shift observed at the target combines the accumulated shift from moving objects with the shifts caused by source and target motion:</p>
<table class="ltx_equation ltx_eqn_table" id="E32">
<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math alttext="\nu_{n}=\nu_{n}^{(\ell)}+\frac{\boldsymbol{\varv}\left(\mathbf{s}\right)^{%
\mathsf{T}}\widehat{\mathbf{k}}_{n}^{(0)}}{\lambda}-\frac{\boldsymbol{\varv}%
\left(\mathbf{t}\right)^{\mathsf{T}}\widehat{\mathbf{k}}_{n}^{(\ell)}}{\lambda}." class="ltx_Math" display="block" id="E32.m1"><mrow><mrow><msub><mi>ν</mi><mi>n</mi></msub><mo>=</mo><mrow><mrow><msubsup><mi>ν</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mfrac><mrow><mi>𝒗</mi><mo>⁢</mo><msup><mrow><mo>(</mo><mi>𝐬</mi><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><mi>λ</mi></mfrac></mrow><mo>−</mo><mfrac><mrow><mi>𝒗</mi><mo>⁢</mo><msup><mrow><mo>(</mo><mi>𝐭</mi><mo>)</mo></mrow><mi>𝖳</mi></msup><mo>⁢</mo><msubsup><mover accent="true"><mi>𝐤</mi><mo>^</mo></mover><mi>n</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><mi>λ</mi></mfrac></mrow></mrow><mo lspace="0em">.</mo></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(32)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math alttext="\boldsymbol{\varv}\left(\mathbf{s}\right)\in\mathbb{R}^{3}" class="ltx_Math" display="inline" id="SS3.SSS2.p2.m4"><mrow><mrow><mi>𝒗</mi><mo>⁢</mo><mrow><mo>(</mo><mi>𝐬</mi><mo>)</mo></mrow></mrow><mo>∈</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math> and <math alttext="\boldsymbol{\varv}\left(\mathbf{t}\right)\in\mathbb{R}^{3}" class="ltx_Math" display="inline" id="SS3.SSS2.p2.m5"><mrow><mrow><mi>𝒗</mi><mo>⁢</mo><mrow><mo>(</mo><mi>𝐭</mi><mo>)</mo></mrow></mrow><mo>∈</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math> denote the velocity vectors of the source and target, respectively.</p>
</div>
</section>
</section>
</section>
</div>
<footer class="ltx_page_footer">
<div class="ltx_align_center">
</div>
<div class="ltx_page_logo">Generated  on Wed Apr 30 18:10:24 2025 by <a class="ltx_LaTeXML_logo" href="http://dlmf.nist.gov/LaTeXML/"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img alt="Mascot Sammy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg=="/></a>
</div></footer>
</div>
</body>
</html>
